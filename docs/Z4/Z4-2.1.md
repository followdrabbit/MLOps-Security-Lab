# Z4-2.1 — Secure ML Workbench (Dev Environment Isolado)

*onde o experimento acontece sem virar “shadow IT” nem vazamento de dados*

O **Secure ML Workbench** é o ambiente de desenvolvimento/experimentação da Z4. Ele permite que cientistas e engenheiros treinem e validem hipóteses **sem acessar Raw**, **sem exportar dados sem controle** e **sem inserir dependências maliciosas**. Tudo é **isolado, rastreável e minimamente privilegiado**.

---

## 1) Objetivo & Princípios

**Objetivo:** oferecer notebooks/IDEs e jobs ad-hoc com **dados curados/feature store**, **segredos via Vault**, **rede controlada**, **imagens corporativas** e **observabilidade total**.

**Princípios:**

* **Isolamento por projeto/time** (namespace/VM) e **identidade forte** (OIDC).
* **Somente leitura** de Z3 (Curated/Feature Store) via broker; **nada direto de Z2**.
* **Egress por allowlist** (PyPI mirror corporativo, registries internos).
* **Segredos fora do código** (Vault Agent/JWT/OIDC).
* **Trilha completa** (runs, artefatos, datasets/feature refs).
* **Não-persistência indevida**: workspaces efêmeros; dados sensíveis nunca “baixados”.

---

## 2) Design de Alto Nível

* **Compute & Isolamento**

  * K8s (ou VMs/containers) por **namespace de projeto**, quotas de CPU/GPU, `PodSecurity`/non-root.
  * **LimitRange/ResourceQuota** para impedir consumo exagerado.
* **Acesso a Dados (via Z3)**

  * Leitura **apenas** de *Curated* e **Feature Store**; contratos de schema + DQ.
  * **ABAC** por domínio/propósito (ex.: `purpose=risk_scoring`).
* **Rede (Egress Control)**

  * Saída **bloqueada por padrão**; allowlist para:

    * registry interno de imagens, **PyPI/NPM mirror corporativo**, repositório Git.
  * **mTLS** para serviços internos (Z3/Z5/Z6/Z8).
* **Segredos**

  * Vault Agent sidecar (templates) injeta tokens/chaves no **tmpfs** do pod.
  * Rotação e escopo mínimo por serviço/usuário.
* **Imagens Base**

  * “ML Base Image” corporativa: non-root, scanners (SCA/SAST), SBOM, `pip/conda` **com lockfile**.
* **Identidade & Acesso**

  * SSO OIDC → grupos/atributos → **RBAC/ABAC** no cluster e nos serviços.
  * MFA para perfis privilegiados (GPU, datasets restritos).
* **Observabilidade**

  * Logs estruturados (quem, o quê, quando, dataset/feature), métricas (GPU, disco, rede), tracing opcional.
  * Tudo integra a **Z9**.

---

## 3) Controles Obrigatórios (Checklist rápido)

* [ ] Namespace por projeto + `ResourceQuota`/`LimitRange`.
* [ ] `NetworkPolicy` **nega-tudo** + allowlist interna.
* [ ] Imagem base assinada + SBOM + dependências “pinned”.
* [ ] **Vault Agent** para segredos (sem `.env` fixo).
* [ ] Montagens **somente-leitura** para dados; proibição de *mounts* locais de usuários.
* [ ] SSO OIDC com roles/atributos mapeados em policies.
* [ ] Logs/métricas de acesso a datasets/features.
* [ ] Saída para internet **bloqueada** (mirror interno apenas).
* [ ] Workspaces efêmeros + limpeza automática.

---

## 4) Fluxo do Dia a Dia (cientista de dados)

1. Usuário acessa **JupyterLab/VSCode Server** via OIDC (SSO).
2. O pod sobe com **Vault Agent** → tokens/segredos são injetados em tmpfs.
3. Notebook lê dados **via broker Z3** (query/SDK/FS), **somente leitura**.
4. Código usa **libs pinadas** da imagem; downloads externos bloqueados (mirror only).
5. Experimentos registram **runs, métricas, artefatos e *lineage*** (MLflow).
6. Todos os acessos/leituras ficam **logados**; exportações de dados são auditadas (e, por padrão, bloqueadas).

---

## 5) Exemplos de Políticas & Manifests (curtos)

### 5.1 Namespace com quotas (K8s)

```yaml
apiVersion: v1
kind: Namespace
metadata: { name: z4-risk-wb }
---
apiVersion: v1
kind: ResourceQuota
metadata: { name: rq, namespace: z4-risk-wb }
spec:
  hard:
    requests.cpu: "8"
    limits.cpu: "16"
    requests.memory: 32Gi
    limits.memory: 64Gi
    requests.nvidia.com/gpu: "0"
    pods: "20"
---
apiVersion: v1
kind: LimitRange
metadata: { name: limits, namespace: z4-risk-wb }
spec:
  limits:
  - type: Container
    default: { cpu: "2", memory: "8Gi" }
    defaultRequest: { cpu: "500m", memory: "2Gi" }
```

### 5.2 NetworkPolicy (nega-tudo + allow interno)

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata: { name: deny-all, namespace: z4-risk-wb }
spec:
  podSelector: {}
  policyTypes: ["Ingress","Egress"]
  ingress: []   # nada entra
  egress:  []   # nada sai
---
# allow para Z3 broker e MLflow/Registry internos
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata: { name: allow-internal, namespace: z4-risk-wb }
spec:
  podSelector: {}
  policyTypes: ["Egress"]
  egress:
  - to:
    - namespaceSelector: { matchLabels: { zone: "z3" } }
    ports: [{ protocol: TCP, port: 8443 }]
  - to:
    - namespaceSelector: { matchLabels: { zone: "z5" } }
    ports: [{ protocol: TCP, port: 5000 }]
```

### 5.3 Segurança de pod & usuário não-root

```yaml
apiVersion: v1
kind: Pod
metadata: { name: jupyter, namespace: z4-risk-wb, labels: { app: wb } }
spec:
  securityContext:
    runAsNonRoot: true
    fsGroup: 10001
  containers:
  - name: lab
    image: registry.corp/ml-base:1.4.0 # imagem assinada
    securityContext:
      allowPrivilegeEscalation: false
      capabilities: { drop: ["ALL"] }
      readOnlyRootFilesystem: true
    volumeMounts:
    - { name: tmp, mountPath: /tmp }
    - { name: secrets, mountPath: /run/secrets, readOnly: true }
  - name: vault-agent
    image: hashicorp/vault:1.17
    args: ["agent","-config=/etc/vault/config.hcl"]
    volumeMounts:
    - { name: secrets, mountPath: /run/secrets }
  volumes:
  - name: tmp
    emptyDir: { medium: Memory }
  - name: secrets
    emptyDir: { medium: Memory }
```

### 5.4 Vault Agent (template de credencial efêmera)

```hcl
# /etc/vault/config.hcl (exemplo)
auto_auth {
  method "kubernetes" { mount_path = "auth/kubernetes" role = "z4-workbench" }
  sink "file" { config = { path = "/run/secrets/.vault-token" } }
}
template {
  source      = "/etc/vault/templates/db.ctmpl"
  destination = "/run/secrets/db.json"
}
```

`db.ctmpl` produzirá JSON com credenciais **temporárias** (rotacionadas).

### 5.5 ABAC (exemplo lógico)

* Atributos de identidade (OIDC claims):
  `group=risk_ml`, `purpose=risk_scoring`, `data_clearance=confidential`
* Policy (pseudocódigo):

```
permit read on curated.risco_transacoes_v2
  when purpose == "risk_scoring"
   and data_clearance in ["confidential","restricted"];
deny read on curated_clientes_restrito when role != "risk_analyst_lead";
```

---

## 6) Práticas de Supply Chain no Workbench

* **Imagem corporativa** (non-root, `apt` bloqueado, ports mínimos).
* **Pin** de dependências + lockfile (`pip-tools/poetry/conda-lock`).
* **SCA/SAST** em PRs + geração de **SBOM** no build.
* **Registro privado** (sem `docker pull` público).
* **Pre-commit hooks** (lint, secrets-scan, policy checks).
* **Sem internet “aberta”**: mirrors internos apenas.

---

## 7) Riscos × Controles × Frameworks

| Risco                 | Controle no Workbench                                        | Onde mapeia                  |
| --------------------- | ------------------------------------------------------------ | ---------------------------- |
| Exfiltração de dados  | NetworkPolicy nega-tudo + allowlists; montagens RO; DLP/logs | NIST SC-7/SC-8, OWASP A09    |
| Dependência maliciosa | Imagem assinada, SBOM, pins/lockfile, registry privado       | OWASP ML-06, NIST SA-*, SLSA |
| Vazamento de segredos | Vault Agent, tokens efêmeros, nada em `.env`                 | NIST AC-*, SC-12/13, CIS     |
| Acesso indevido a PII | OIDC+ABAC, RLS/CLS por dataset/feature                       | NIST AC-6, LGPD/GDPR         |
| Consumo excessivo/DoS | Quotas/limits, auto-scaling controlado                       | NIST SC-5, CSA SEF           |
| Shadow data/pipeline  | Somente leitura de Z3 via broker, logs obrigatórios          | NIST AU-2/6, OWASP A09       |

---

## 8) Implementação no Lab (simples e fiel)

**Opção Docker Compose (VPS única):**

* `jupyterlab` atrás do **Traefik** com OIDC (Keycloak) e mTLS interno.
* Sidecar **Vault Agent** + volume `tmpfs` para segredos.
* Rede `proxy` (Traefik) + rede interna para Z3/Z5.
* Mirror local do PyPI (ou **pip** bloqueado; dependências no build da imagem).

**Passos:**

1. Construir imagem `ml-base` (non-root, pins, SBOM).
2. Subir Keycloak/Traefik (Docs 05) e Vault (Docs 01/03).
3. Subir `jupyterlab` com labels de OIDC e **Vault Agent** sidecar.
4. Testar leitura **apenas** de Z3 Curated/Feature Store.
5. Confirmar logs de acesso e bloqueio de egress não autorizado.

---

## 9) Runbooks (resumo)

* **Egress suspeito** → bloquear regra de `NetworkPolicy`, coletar `pod logs`, `conntrack`, `pcap` interno.
* **Notebook com pacote não aprovado** → impedir build/pull; PR para incluir no lockfile e rebuild da imagem.
* **Tentativa de ler Z2** → negar via broker; alerta na Z9; revisão de roles.
* **Segredo vazado** → revogar no Vault, rodar rotação automática e auditoria de acessos.

---

## 10) Frase pronta para a entrevista

> “Nosso workbench é isolado por projeto, non-root e com egress por allowlist. Cientistas só leem Z3 via broker com ABAC, segredos vêm do Vault Agent, dependências são pinadas com SBOM, e toda ação é logada para Z9. Isso impede shadow pipelines, exfiltração e supply-chain malicioso ainda na fase de experimento.”
