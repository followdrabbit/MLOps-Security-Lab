# Z4-2.2 — Dataset & Feature **Access Broker** (via Z3)

*o “porteiro inteligente” entre o Workbench (Z4) e os dados oficiais (Z3)*

O **Access Broker** é um serviço/ camada que **media todo acesso** da Z4 aos **datasets Curated** e à **Feature Store** da Z3. Em vez de cada notebook, job ou microserviço conectar direto no banco/objeto, **tudo passa pelo broker**, que aplica **AuthN/AuthZ, ABAC, contratos de schema, masking/PII, RLS/CLS, quotas, shape de consulta, logs e lineage**.
Resultado: **leitura somente do que é permitido, do jeito permitido, com trilha completa**.

---

## 1) Objetivo & Princípios

**Objetivo:** garantir que cientistas/ jobs da Z4 **só leiam** dados **oficiais** (Z3) sob **mínimo privilégio**, com **propósito declarado** e **controles verificáveis**.

**Princípios-chave**

* **Somente via broker** (nada de conexão direta a bancos/objetos da Z3).
* **Identidade forte + contexto**: OIDC/JWT + *claims* (projeto, domínio, propósito).
* **ABAC** + **RLS/CLS**: autorização por atributos e por linha/coluna.
* **Dados sensíveis por padrão mascarados/ tokenizados** (Z3-2.5).
* **Somente leitura**, **consultas parametrizadas**, **shape controlado** (anti-scan).
* **Credenciais efêmeras** (Vault), **mTLS**, **auditoria rica** (quem/que/porque).
* **Lineage**: toda leitura registra dataset/versão/feature group usados.

---

## 2) Arquitetura (alto nível)

```
Z4 Workbench/Jobs  ──(mTLS + JWT)──►  Access Broker  ──►  Z3 (Curated / Feature Store)
                               ▲                │
                        Vault / OIDC       Policy Engine (ABAC)
                               │                │
                               └── Audit/Lineage ──► Z9
```

**Componentes**

* **Client SDK** (python/CLI) no Workbench: injeta `correlation_id`, JWT do OIDC, métricas.
* **API do Broker** (FastAPI/gRPC): endpoints **somente leitura** (`/query`, `/feature/get`, `/feature/vector`).
* **Policy Engine** (ex.: OPA ou regras nativas): aplica ABAC, RLS/CLS, masking.
* **Connectores Z3**: conexões **read-only** a bancos/objetos Curated e Feature Store (offline/online).
* **Audit/Lineage Emitter**: envia logs/linhas de proveniência à Z9 e anexa aos runs (MLflow).

---

## 3) Fluxo de Requisição (passo a passo)

1. **Identidade & Contexto**

   * O usuário/job chama o broker com **JWT OIDC** e **mTLS**.
   * Claims incluem: `sub`, `project`, `groups`, `purpose` (ex.: `risk_scoring`), `data_clearance`.

2. **Autorização (ABAC + RBAC)**

   * O broker avalia: *“Pode ler este dataset/feature group?”*
     Base em: domínio (`risk`, `fraud`), sensibilidade (`restricted/confidential`), finalidade.

3. **Shaping & Contratos**

   * Broker valida **contrato de schema** (Z3), **limita colunas** (CLS) e **linhas** (RLS).
   * **Desabilita**: `SELECT *`, funções perigosas, `UNLOAD/COPY`, *full scans* fora de perfil.
   * Impõe **filtros de período**, **limites de linhas**, **paginação** e **tempo de execução**.

4. **Credenciais Efêmeras**

   * Broker obtém credenciais **read-only e temporárias** via **Vault** (DB Secrets / STS).
   * Executa a consulta de forma parametrizada no storage da Z3.

5. **PII Handling**

   * Se colunas marcadas `pii=true`:

     * aplica **mask**/**tokenização**; só revela *clear-text* se a policy autorizar.

6. **Resposta + Audit/Lineage**

   * Retorna dados + **metadados de lineage** (dataset, snapshot, feature group e versão).
   * Emite **audit event** (`who/what/why/how many/columns sensíveis`) para a Z9.

---

## 4) Controles Técnicos (o que o Broker impõe)

### 4.1 Identidade, Sessão & Canal

* **mTLS obrigatório** entre Z4↔Broker↔Z3 (serviço-to-serviço).
* **JWT OIDC** com *claims*: `sub`, `groups`, `project`, `purpose`, `data_clearance`.
* **Expiração curta** + **rotina de revogação**.

### 4.2 Autorização (ABAC/RBAC)

* **RBAC**: papéis como `role:risk_analyst`, `svc:fraud_scorer`.
* **ABAC**: atributos em claims:
  `purpose=risk_scoring`, `domain=risk`, `data_clearance ∈ {confidential, restricted}`.
* **Políticas por dataset/feature group**: quem pode ler o quê e **com quais colunas**.

### 4.3 Query Shaping & Anti-Exfiltração

* **Só consultas parametrizadas**; **nega `SELECT *`**; **whitelist** de colunas.
* **RLS** (Row-Level Security) por `entity_id`, região, etc.
* **CLS** (Column-Level Security) para PII/`restricted`.
* **Tempo máximo de execução**, **limite de linhas**, **limite de bytes** por resposta.
* **Rate limit & quotas** por identidade/projeto.
* **Bloqueio de funções**: `COPY/UNLOAD`, `pg_read_file`, extensões perigosas, etc.

### 4.4 PII & Minimização

* **Mascaramento por padrão** para PII:

  * ex.: `email` → `***@dominio.com`.
* **Tokenização determinística** (via Vault Transit) quando join é necessário.
* **Desanonimização excepcional** (auditoria reforçada) só com base legal/role adequado.

### 4.5 Linhagem & Evidências

* Para cada chamada: grava `dataset`, `version/snapshot`, `feature_group@vN`, `git_sha` do pipeline produtor (se disponível).
* Anexa `lineage_ref` ao **run_id** no MLflow (Z4-2.6).

---

## 5) Exemplos (config & código)

### 5.1 Exemplo de **RLS** (Postgres)

```sql
-- Habilita RLS na tabela curada
ALTER TABLE curated.risco_transacoes_v2 ENABLE ROW LEVEL SECURITY;

-- Policy: permite linhas do domínio do projeto do usuário
CREATE POLICY rlsp_risco_project
ON curated.risco_transacoes_v2
USING ( current_setting('app.project') = project_tag );

-- O broker seta `app.project` na sessão antes da query:
-- SET app.project = 'risk_scoring';
```

### 5.2 **CLS** (mascaramento por coluna)

```sql
CREATE OR REPLACE VIEW v_risco_transacoes_masked AS
SELECT
  customer_id,
  CASE WHEN has_clearance('restricted') THEN email
       ELSE regexp_replace(email,'^.+(@.*)$','***\1') END AS email,
  valor, ts
FROM curated.risco_transacoes_v2;
```

> O broker expõe **apenas a view** para identidades sem `restricted`.

### 5.3 **Policy ABAC** (pseudo-OPA/Rego)

```rego
package broker.authz

default allow = false

allow {
  input.claims.purpose == "risk_scoring"
  input.claims.domain == "risk"
  dataset := input.request.dataset
  dataset == "curated.risco_transacoes_v2"
  not contains_restricted_columns(input.request.columns, input.claims.data_clearance)
}
```

### 5.4 **Credenciais dinâmicas (Vault DB Secrets)** (conceito)

* Broker chama `database/creds/ro_z3_curated` → recebe usuário/ senha **TTL=5min**.
* Abre conexão, executa consulta parametrizada, **descarta** as credenciais.

### 5.5 **Client SDK (Python)**

```python
from mlsec_broker import BrokerClient

bc = BrokerClient(base_url="https://broker.internal",
                  tls_cert="/run/tls/cert.pem",
                  jwt_path="/run/secrets/jwt",
                  correlation_id="run-123-xyz")

df = bc.query(
  dataset="curated.risco_transacoes_v2",
  columns=["customer_id", "valor", "ts"],
  where={"ts__gte": "2025-11-01", "ts__lt": "2025-11-08"},
  limit=100000
)
# lineage refs disponíveis em df.attrs["lineage"]
```

---

## 6) Integração com **Feature Store** (Z3-2.6)

* **Offline**: broker materializa *feature groups* aprovados (ex.: `fs_offline.risco_cliente_v1`) sob as mesmas regras de RLS/CLS.
* **Online**: APIs do broker chamam a **Online Feature Store** via mTLS, entregando **apenas** vetores autorizados (`get_feature_vector(customer_id)`), com TTL e masking quando aplicável.
* **Consistência treino↔produção**: as mesmas transforms e *feature views* são usadas; *code reuse* e *manifests*.

---

## 7) Anti-patterns que o Broker elimina

* Notebook conectando direto no banco de Curated com `SELECT *`.
* Query exportando dataset inteiro (ex.: CSV) sem mascaramento.
* Time treinando com colunas `restricted` sem base legal.
* Scripts com credencial fixa em `.env`.
* Job lendo **Raw (Z2)** “pra ganhar tempo”.

---

## 8) Implementação no **Lab** (enxuto e fiel)

1. **Suba o Access Broker** (FastAPI) atrás do Traefik (mTLS interno).
2. **Integre com OIDC** (Keycloak) e **Vault** (DB Secrets + Transit).
3. **Implemente 3 rotas**:

   * `POST /query` (somente leitura, parametrizada),
   * `GET /feature/vector?entity_id=...`,
   * `GET /catalog/schema?dataset=...` (espelha schema & sensibilidade).
4. **Ative RLS/CLS** no Postgres/ClickHouse/engine que você usa.
5. **Crie políticas ABAC** (OPA ou no próprio broker).
6. **Logue tudo** para Z9 (+ *correlation_id* vindo da Z1).
7. **SDK Python** simples para o Workbench e para DAGs.

---

## 9) Riscos × Controles × Frameworks

| Risco                                | Controles do Broker                                                                          | Frameworks                                  |
| ------------------------------------ | -------------------------------------------------------------------------------------------- | ------------------------------------------- |
| **Acesso indevido/Exposição de PII** | OIDC+mTLS, ABAC, RLS/CLS, masking/tokenização por padrão                                     | NIST AC-2/3/6, LGPD/GDPR, CSA CCM (IAM/DSI) |
| **Exfiltração/Coleta massiva**       | Query shaping, limites de linhas/bytes/tempo, bloqueio de `SELECT *`, rate limits, auditoria | OWASP API A04/A10, NIST AU-6, SI-4          |
| **Shadow pipeline/Bypass da Z3**     | Somente via broker; credenciais efêmeras; deny direto ao storage                             | OWASP A09 (logging/monitoring), NIST SC-7   |
| **Target/Attribute leakage**         | Policies por finalidade, bloqueio de colunas sensíveis, catálogo + schema contracts          | NIST AI RMF (Manage/Measure), OWASP ML      |
| **Injection / Query abuse**          | Consultas **parametrizadas**; bloqueio de funções perigosas                                  | OWASP Top 10/ASVS (Injection)               |
| **Skew treino→prod**                 | Reuso das mesmas *feature views*; lineage por chamada                                        | OWASP ML08; NIST AI RMF                     |

---

## 10) Runbooks (operação & resposta)

* **Alerta de exfiltração (volume fora do perfil)**
  Ação: bloquear identidade no IdP, suspender policy, revisar logs de `who/what/columns`, comunicar SOC.
* **Uso de coluna `restricted` sem autorização**
  Ação: negar resposta, abrir incidente, verificar `purpose`, atualizar/treinar políticas.
* **Tentativa de bypass (conexão direta)**
  Ação: bloquear rede/SG/Firewall, caçar credenciais estáticas, registrar “Shadow Data Incident”.
* **Erros de performance/timeout**
  Ação: revisar *query plan*, ajustar *views/materializações*, aumentar *caches* controlados no broker.

---

## 11) Frase pronta para entrevista

> “**Na nossa fábrica (Z4), ninguém conecta direto no dado.** Todo acesso passa por um **Access Broker** que aplica **OIDC+mTLS, ABAC, RLS/CLS, masking/PII, limites de consulta e auditoria**. O broker ainda injeta **lineage** em cada leitura, emite eventos para a Z9 e fornece **credenciais efêmeras** via Vault. Assim, **apenas dados e features oficiais** da Z3 são usados, **somente leitura** e estritamente dentro do **propósito declarado**.”
