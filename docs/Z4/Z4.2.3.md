# Z4-2.3 — Training Pipelines (CI/CD) — **Segurança & Reprodutibilidade**

*onde o treinamento vira uma esteira previsível, auditável e blindada contra supply chain*

O objetivo desta seção é transformar **treino de modelos** em um **processo de software confiável**: versionado, repetível, com **gates de segurança**, **evidências** e **assinatura de artefatos**. Nada segue adiante se qualquer teste (código, segurança, dados ou desempenho) falhar.

---

## 1) Por que existe (Objetivo & Princípios)

**Objetivo:** garantir que cada modelo treinado tenha **proveniência completa** (dados, código, ambiente), **conformidade** (privacidade/ética), **segurança de cadeia de suprimentos** e **reprodutibilidade prática**.

**Princípios-chave**

* **Everything-as-code** (pipeline, infra, dados de referência, thresholds).
* **Imutabilidade**: imagens/artefatos por **digest**; sem “latest”.
* **Determinismo prático**: seeds + *locks* + captura do ambiente.
* **Gates** obrigatórios (build → teste → segurança → treino → avaliação → assinatura).
* **Sem internet “aberta” em treino** (egress control; mirrors internos).
* **Registros ricos** no tracker (MLflow) + logs/métricas na Z9.

---

## 2) Arquitetura de Alto Nível (duas “lanes”)

```
┌───────────────┐   PR/Commit   ┌──────────────────────────┐
│ Source (Git)  ├──────────────►│ CI: Build & Security Gate│
└───────┬───────┘               └────────────┬─────────────┘
        │                                      (SBOM, SAST/SCA, signé)
        │                                        digest
        │                          ┌────────────▼────────────┐
        │                          │   Image Registry (RO)   │
        │                          └────────────┬────────────┘
        │                                      (digest pin)
        │                          ┌────────────▼────────────┐
        │                          │  Orquestrador de Treino │  ◄─(Airflow)
        │                          └────────────┬────────────┘
        │                                 exec   │   track
        │                          ┌────────────▼────────────┐
        │                          │   Training Job (Z4)     │─► MLflow (runs, artefatos)
        │                          └────────────┬────────────┘
        │                                  eval │  (gates)
        │                          ┌────────────▼────────────┐
        └──────────────────────────│  Gate Final + Assinatura│─► Z5 (Registry)
                                   └──────────────────────────┘
```

* **Lane 1 — Build & Segurança:** compila imagem/ambiente, roda scanners (SAST/SCA, *image scan*, SBOM), **assina** e publica por **digest**.
* **Lane 2 — Treino & Avaliação:** agenda treino **somente com imagem assinada**, captura proveniência, roda **avaliação + testes adversariais** e aplica **gates** antes da promoção.

---

## 3) Controles por Fase (do commit ao registro)

### 3.1 Código & Dependências

* **Branch protection** (revisão obrigatória, `CODEOWNERS`).
* **Pre-commit**: lint, formatação, **secrets scan**.
* **Pins/lockfiles** (`pip-tools/poetry/conda-lock`).
* **SCA** (dependências e licenças) + **SAST** (código do treino/serving).
* **SBOM** (Syft/tern) armazenado como artefato.

### 3.2 Build de Imagem (supply chain)

* Base **corporativa** (non-root, hardening, sem shells extras).
* **Sem downloads em tempo de execução** (somente mirrors internos).
* **Scan de imagem** (Trivy/Grype) com *policy gate* (CVEs críticos → FAIL).
* **Assinatura** (cosign; keyless via OIDC) e **attestation** (SLSA/provenance).
* Publicação com **digest** (pinned).

### 3.3 Orquestração do Treino

* Job (Airflow/K8s) executa **por digest**, com **service account RO**.
* **Vault Agent** injeta segredos efêmeros (tokens/DSN).
* **Sem egress** para internet; apenas Z3/Z5/Z9 (mTLS).
* **Quotas/recursos** definidos (GPU/CPU/memória; *time-out* e *retries*).

### 3.4 Higiene de Dados & Labels (pré-treino)

* **Schema & contratos** (Z3) verificados.
* **Deduplicação**; checagem de **target leakage** (temporal/causal).
* Estatísticas base (PSI/KL) salvas como **baseline**.
* **Consentimento/base legal** para atributos sensíveis (bloqueios e avisos).

### 3.5 Execução do Treino (reprodutibilidade)

* **Seeds fixas** + controle de determinismo (torch/cuda, *cudnn.deterministic* quando aplicável).
* **Captura de ambiente**: `git_sha`, `container_digest`, `sbom_ref`, versões de libs, **hash** de inputs (dataset/feature groups).
* Registro contínuo no **MLflow** (métricas, artefatos, grafos).

### 3.6 Avaliação & Gates (funcional + segurança)

* Métricas mínimas (AUC/KS/Recall etc.) e **faixas por segmento** (fairness).
* **Testes adversariais** (gatilho para Z4-2.5): evasão, privacy (MI/MI), backdoors.
* **Output integrity** (sanidade de scores/intervalos).
* **Política de promoção**: se qualquer gate falhar → **FAIL** com evidências.

### 3.7 Empacote & Assine (handoff para Z5)

* Gera **artefatos** (onnx/pt/wheel/tokenizer).
* Calcula **checksums**; **assina** artefatos e **gera attestation**.
* **Model Card** + **relatórios** (métricas, fairness, riscos, dados, salvaguardas).
* Envia **manifest de proveniência** para Z5 (Registry) e **Z9** (evidências).

---

## 4) Metadados **obrigatórios** no Tracking (por run)

* `run_id`, `git_sha`, `container_digest`, `sbom_ref`, `cosign_sig`.
* `dataset_refs` (Z3 Curated) + `dataset_hash`/snapshot.
* `feature_groups` (ex.: `fs_offline.risco_cliente_v1@v1`).
* `hyperparams` + **seeds**.
* métricas macro e por subgrupo (fairness).
* **artefatos** (pesos, configs, gráficos, relatórios).
* **policy_decision** (PASS/FAIL) com motivos.

---

## 5) Exemplos (YAML, Airflow, script de gate)

### 5.1 GitHub Actions — *Build & Security Gate* (exemplo resumido)

```yaml
name: build-train-image
on:
  pull_request: {}
  push: { branches: ["main"] }

jobs:
  build:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      id-token: write  # OIDC p/ cosign keyless
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with: { python-version: "3.11" }
      - name: Install build deps
        run: pip install -r requirements-build.txt
      - name: Pre-commit + SAST
        run: |
          pre-commit run --all-files
          bandit -r src/ -q
      - name: SCA + Licenses
        run: pip install safety && safety check -r requirements.txt
      - name: Build image
        run: docker build -t registry.corp/ml-train:${{ github.sha }} .
      - name: SBOM
        run: syft packages registry.corp/ml-train:${{ github.sha }} -o spdx-json > sbom.json
      - name: Vulnerability scan
        run: trivy image --exit-code 1 --severity CRITICAL,HIGH registry.corp/ml-train:${{ github.sha }}
      - name: Push image (by digest)
        run: |
          docker push registry.corp/ml-train:${{ github.sha }}
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' registry.corp/ml-train:${{ github.sha }})
          echo "DIGEST=$DIGEST" >> $GITHUB_ENV
      - name: Cosign sign (keyless OIDC)
        run: cosign sign --yes $DIGEST
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with: { name: build-metadata, path: "sbom.json" }
```

### 5.2 Airflow — *Treino por digest* (KubernetesPodOperator)

```python
from airflow import DAG
from airflow.providers.cncf.kubernetes.operators.kubernetes_pod import KubernetesPodOperator
from datetime import datetime

with DAG("train_risco_model", start_date=datetime(2025,11,1), schedule=None, catchup=False) as dag:
    train = KubernetesPodOperator(
        name="train",
        task_id="train",
        namespace="z4-train",
        image="{{ var.value.ML_TRAIN_IMAGE_DIGEST }}",  # pin por digest
        cmds=["python", "train.py"],
        arguments=["--config", "/run/config/train.yaml"],
        env_vars={"MLFLOW_TRACKING_URI": "http://mlflow.z4.svc:5000"},
        is_delete_operator_pod=True,
        get_logs=True,
        container_resources={
          "limits": {"cpu":"8","memory":"32Gi","nvidia.com/gpu":"1"},
          "requests":{"cpu":"2","memory":"8Gi"}
        },
        security_context={"runAsNonRoot": True, "allowPrivilegeEscalation": False},
        # network: sem egress externo; mTLS interno configurado via sidecar
    )
```

### 5.3 Gate Script (aplica política de promoção)

```python
import json, sys
m = json.load(open("metrics.json"))
fair = json.load(open("fairness.json"))
adv  = json.load(open("adversarial.json"))

errors = []
if m["auc"] < 0.82: errors.append("AUC abaixo do mínimo 0.82")
if fair["ks_diff_max"] > 0.12: errors.append("Fairness KS diff > 0.12")
if adv["membership_inference_risk"] != "low": errors.append("Membership inference não é LOW")

if errors:
    print("FAIL:", "; ".join(errors))
    sys.exit(1)
else:
    print("PASS: métricas e segurança OK")
```

---

## 6) Políticas de Promoção (exemplo prático)

* **Só promove** se:

  * scanners (código/dependência/imagem) **PASS**,
  * **SBOM** gerado e armazenado,
  * treino executado com **imagem assinada** por **digest**,
  * **higiene de dados** (Z4-2.4) **PASS**,
  * **testes adversariais** (Z4-2.5) **PASS**,
  * métricas ≥ thresholds + fairness dentro de limites,
  * artefatos **assinados** + **attestations** presentes,
  * **Model Card** preenchido.
* Caso **FAIL**:

  * bloquear merge/promoção,
  * abrir *issue* com evidências,
  * acionar **runbook**.

---

## 7) Runbooks (quando algo dá errado)

* **Falha em scanner de imagem (CVEs)**
  → Atualizar base, *rebuild*, se necessário **pin down** de versão; justificar exceções (tempo limitado, plano de correção).
* **Reprodutibilidade falhou (métricas não batem)**
  → Conferir seeds/versões, `container_digest`, `dataset_hash`; fixar *cudnn.deterministic*; revisar *randomness*.
* **Target leakage detectado**
  → Analisar *features* e janelas; bloquear artefato; ajustar pipeline; documentar no Model Card.
* **Gate adversarial falhou**
  → Investigar fontes/regularização/defesas; re-treinar; revisar limites de exposição de atributos.
* **Assinatura/attestation ausentes**
  → Impedir promoção automática; reexecutar etapa de assinatura; auditar permissões do pipeline.

---

## 8) Riscos × Controles × Frameworks

| Risco                                         | Controles (nesta seção)                                                               | Frameworks                                         |
| --------------------------------------------- | ------------------------------------------------------------------------------------- | -------------------------------------------------- |
| **ML Supply Chain** (lib/contêiner malicioso) | Build corporativo, SAST/SCA, *image scan*, SBOM, **cosign** + attestation, digest pin | OWASP ML-06; NIST SP 800-53 SA-*, CM-*, SI-*, SLSA |
| **Poisoning/Backdoors**                       | Z4-2.4 (higiene), Z4-2.5 (adversarial), proveniência Z3/Z4                            | OWASP ML-02/ML-10; NIST AI RMF (Measure/Manage)    |
| **Reprodutibilidade fraca**                   | Seeds + *locks*, captura de ambiente, digest pin, MLflow                              | NIST AI RMF; CSA AICM (LOG/SEF)                    |
| **Uso indevido de PII**                       | Contratos de schema Z3, masking/tokenização herdados, gates de ética                  | LGPD/GDPR; NIST AC-6; CSA DSI                      |
| **Skew treino→prod**                          | Mesma imagem/transform, *feature views* oficiais (Z3-2.6), *manifests*                | OWASP ML-08; NIST AI RMF                           |
| **Exfiltração/custos**                        | Egress bloqueado, quotas, timeouts, logs → Z9                                         | NIST SC-7/SC-8; OWASP A09                          |

---

## 9) Dicas de operação no Lab (pé-no-chão)

* Armazene `DIGEST` como *variable/secret* do Airflow; **nunca** `:latest`.
* Gere **SBOM** e publique junto ao run no MLflow (artefato *sbom.json*).
* Crie um **“baseline.json”** com thresholds de métrica/fairness por produto de risco.
* Empacote testes adversariais como **`tests_security/`** e chame no final do treino.
* Publique **attestations** (provenance) em um bucket somente leitura para a Z5.

---

## 10) Frase pronta para entrevista

> “Nossos **training pipelines** funcionam como uma **esteira de software crítico**: builds com **SBOM + scanners + assinatura**, treino **por digest** em ambiente isolado e sem egress, **higiene de dados/labels**, **avaliação + testes adversariais**, e **gates de promoção**. Só registramos na Z5 artefatos **assinados**, com **proveniência comprovada** e **Model Card** completo — tudo rastreado no MLflow e auditável na Z9.”
