# Z4-2.7 — **Empacotamento, Assinatura & Submissão ao Registry (handoff p/ Z5)**

*“sem artefato assinado e com proveniência, não entra no catálogo de produção”*

Esta etapa pega o **modelo candidato** (que já passou por **Higiene** Z4-2.4 e **Adversarial & Security Testing** Z4-2.5, com **tracking** Z4-2.6) e realiza três coisas, de forma **automatizada e auditável**:

1. **Empacotar** tudo que é necessário para reproduzir e operar o modelo,
2. **Assinar** artefatos e **gerar attestations** (proveniência/supply chain),
3. **Submeter** ao **Z5 — Model Registry & Governance** sob políticas de aprovação.

> Meta: tornar o **Registry (Z5)** a “**única fonte de verdade**” para modelos, contendo **artefatos imutáveis**, **assinados**, com **evidências** e **governança** (aprovação, versionamento, revogação).

---

## 1) O que vai no pacote (manifesto do artefato)

O pacote do modelo (enviado ao Registry) contém **arquivos + metadados**:

* **Artefatos de modelo**

  * Pesos/graph: `model.onnx` ou `model.pt`/`model.pkl` (ou `model/` no formato da sua stack)
  * **Pré/pós-processamento**: `preprocess.py`, `inference_config.yaml`
  * **Constraints** (ex.: `pydantic`/`marshmallow`/`jsonschema` para requests/respostas)
* **Metadados de reprodutibilidade**

  * `git_sha`, `container_digest` (imagem de treino), `sbom_ref`
  * `dataset_id@snapshot`, `dataset_hash`, `feature_groups@version`
  * Hiperparâmetros, *seeds*, ambiente (CUDA/cuDNN, libs)
* **Evidências de segurança & qualidade**

  * `reports/hygiene/*` (Z4-2.4), `reports/security/*` (Z4-2.5)
  * `security_decision.txt` (**PASS/FAIL**)
  * Métricas por subgrupo (fairness)
* **Governança**

  * `model_card.md` (finalidade, risco, salvaguardas, limites)
  * `scdr_id`/`adr_id` (decisões de controle/arquitetura associadas)
* **Integridade & supply chain**

  * `checksums.json` (sha256 dos arquivos críticos)
  * **Assinaturas** (`signatures/model.sig`, `signatures/…`)
  * **Attestations** (ex.: `intoto/provenance.json`, SLSA)
  * Referência no **Rekor** (transparency log), quando aplicável

> **Imutabilidade**: após enviado, **não se edita**; novas mudanças geram **novo versionamento**.

---

## 2) Assinatura & Attestation (como e por quê)

**Objetivo:** garantir **integridade, autenticidade e cadeia de confiança** do modelo e do que o cerca.

* **Assinatura de artefatos**

  * Ferramenta típica: **cosign** (sigstore) com **OIDC keyless** ou chaves armazenadas em **KMS/HSM**
  * O que assinar:

    * arquivos de modelo (`model.onnx` etc.)
    * manifest do pacote (`checksums.json`)
    * **imagem** do *runtime* de inferência (quando aplicável)
* **Attestation (proveniência/SLSA)**

  * Descrever **quem construiu**, **como**, **a partir de quê** (git/image digest/snapshot)
  * Gerar *in-toto provenance* vinculando **build** → **treino** → **modelo**
* **Transparência**

  * Registrar a assinatura no **Rekor** (transparency log)
  * Guardar referências no **Registry** (Z5) e no run (Z4-2.6)

> **Política**: **sem assinatura, sem attestation, sem Registry**.

---

## 3) Submissão ao **Z5 — Model Registry & Governance**

A submissão é **API-driven**: o pipeline envia o pacote com **metadados**, **assinaturas** e **evidências**; o Registry aplica **políticas de aceitação**.

### 3.1 Regras de aceitação (Policy-as-Code)

O Registry valida, **antes de aceitar**:

* `security_decision == "PASS"` (Z4-2.5)
* Presença de: `SBOM`, `cosign_sig`, `attestation`, `checksums`
* `git_sha`, `container_digest`, `dataset@snapshot` (Z4-2.6)
* `model_card.md` preenchido (finalidade/risco)
* Licença e uso de dados: **base legal/propósito** consistente (LGPD)
* **Assinatura válida** (cadeia conf. → KMS/HSM/OIDC) e **não revogada**

*Ex.: OPA/Rego dentro do Registry decide “accept/reject”.*

### 3.2 Versionamento & estados

* **Versionamento** por **digest imutável** + *semantic tag*
* Estados: `Candidate` → `Staging` (teste integrado) → `Approved`
* Mudança de estado requer **aprovação** (automática ou *four-eyes principle* segurança/privacidade/negócio)

### 3.3 Ligações de governança

* Vincula **run_id** (MLflow), `scdr_id`/`adr_id`
* Gera **eventos p/ Z9** (auditoria)
* Mantém **histórico** de quem aprovou, quando, sob qual política

---

## 4) Verificações no upload & no download

* **No upload (entrada no Z5)**

  * Verificar **assinaturas** e **attestations**
  * Validar **checksums** vs. `checksums.json`
  * Bloquear se **qualquer** evidência faltar
* **No download (consumo por Z6)**

  * **Reverificar** assinaturas; checar se a versão **não está revogada**
  * Conferir `security_decision=PASS` e políticas de *runtime* (p.ex., limites de *output*)

> **Defense-in-depth**: validação **dupla** (entrada e consumo).

---

## 5) Exemplo de comandos (didáticos)

### 5.1 Gerar `checksums.json`

```bash
jq -n '{
  files: [
    {path:"model/model.onnx", sha256:"'$(sha256sum model/model.onnx | cut -d" " -f1)'" },
    {path:"inference_config.yaml", sha256:"'$(sha256sum inference_config.yaml | cut -d" " -f1)'" }
  ]
}' > checksums.json
```

### 5.2 Assinar com **cosign** (keyless OIDC)

```bash
# Assina o arquivo de modelo
cosign sign-blob --yes --output-signature signatures/model.sig model/model.onnx

# Assina o manifesto de checksums
cosign sign-blob --yes --output-signature signatures/checksums.sig checksums.json

# (Opcional) assina a imagem de runtime de inferência por digest
cosign sign --yes registry.corp/ml-serving@sha256:ABCDEF...
```

### 5.3 Gerar **attestation** (in-toto/SLSA – exemplo simplificado)

```bash
cat > intoto/provenance.json <<'JSON'
{
  "_type": "https://in-toto.io/Statement/v0.1",
  "subject": [{ "name": "model/model.onnx", "digest": { "sha256": "…" } }],
  "predicateType": "https://slsa.dev/provenance/v1",
  "predicate": {
    "buildType": "ml-train-pipeline@v1",
    "builder": {"id": "github-actions://org/repo/workflow/train"},
    "invocation": {
      "configSource": {"uri":"git+ssh://repo","digest":{"gitSha":"…"}},
      "parameters": {"seed": 42, "hyperparams": {"lr": 0.001}}
    },
    "metadata": {"buildStartedOn":"…","buildFinishedOn":"…"}
  }
}
JSON

cosign attest --yes --predicate intoto/provenance.json \
  --type slsaprovenance registry.corp/models/risk-default@sha256:...
```

### 5.4 Submeter ao **Registry** (MLflow Python – exemplo)

```python
import mlflow
client = mlflow.tracking.MlflowClient()

# Registra novo "ModelVersion" apontando pro run e anexando metadados
mv = client.create_model_version(
    name="risk-default",
    source=f"{run.info.artifact_uri}/model",
    run_id=run.info.run_id,
    tags={
      "security_decision": "PASS",
      "cosign": "present",
      "attestation": "intoto/provenance.json",
      "dataset_snapshot": manifest["snapshot_at"],
      "container_digest": os.getenv("TRAIN_IMAGE_DIGEST")
    }
)

# Opcional: mover p/ "Staging" após checagens automáticas
client.transition_model_version_stage(
    name="risk-default",
    version=mv.version,
    stage="Staging",
    archive_existing_versions=False
)
```

---

## 6) Revogação, *rollbacks* e chaves

* **Revogação**: se vulnerabilidade/risco posterior, marcar versão como **REVOKED** no Z5; Z6 **não** deve carregar/reter esse modelo (limpar cache).
* **Rollback**: promover versão anterior **Approved**; logar decisão (Z9) e anexar **SCDR** de incidente.
* **Gestão de chaves**:

  * Assinaturas com chaves no **KMS/HSM** (ou **keyless OIDC**); **rotação** periódica
  * **Lista de revogação** (CRL) para chaves comprometidas
  * Acesso a chaves **segregado** (SoD)

---

## 7) Políticas típicas (exemplos)

* **Acceptance policy (OPA/Rego – pseudo):**

```rego
package registry.accept

default allow = false

allow {
  input.tags.security_decision == "PASS"
  input.artifacts.sbom == true
  input.artifacts.signatures.model == true
  input.artifacts.attestation == true
  input.meta.git_sha != ""
  input.meta.container_digest != ""
  input.meta.dataset_snapshot != ""
}
```

* **Promotion gates** (`Candidate` → `Staging` → `Approved`)

  * *Staging*: integração com um dataset *holdout* adicional + limites de latência e conformidade de *runtime*
  * *Approved*: *four-eyes* (Segurança + Dono de Produto) e **verificação final** de assinatura/attestation

---

## 8) Integrações com Z6 (o que o serving exige)

* **Somente carrega** modelos do Registry **com**:

  * `stage in {"Staging","Approved"}` (conforme ambiente)
  * `security_decision=PASS`
  * **assinatura válida** e **não revogada**
* **Startup check**: Z6 valida **assinatura**, **attestation**, **digest** do *runtime*, publica `model_version/run_id` no Z9
* **Runtime policy**: limites de *output*, *rate*, privacidade (para LLM), **ligados aos metadados** do Z5

---

## 9) Riscos × Controles × Frameworks

| Risco                                 | Controles (Z4-2.7)                                                                       | Referências                                |
| ------------------------------------- | ---------------------------------------------------------------------------------------- | ------------------------------------------ |
| **Supply chain** (artefato trocado)   | Assinatura cosign, attestation SLSA/in-toto, checksums, verificação no upload e download | NIST SSDF, SLSA, NIST SP 800-53 SA-*, CM-* |
| **Modelo sem evidência de segurança** | Policy “no evidence, no deploy”: exige Z4-2.4/2.5/2.6                                    | NIST AI RMF (Manage/Measure), OWASP ML     |
| **Modelo revogado em produção**       | Flag **REVOKED** no Z5 + verificação no Z6 + limpeza de cache                            | NIST SI-4, IR-4; CSA CCM (LOG/SEF)         |
| **Chave comprometida**                | KMS/HSM, rotação, CRL, SoD                                                               | NIST SC-12/SC-13; ISO/IEC 27001 A.8        |
| **Governança opaca**                  | Model Card, SCDR/ADR, trilhas Z9, *four-eyes*                                            | ISO/IEC 23894, LGPD, NIST AI RMF           |

---

## 10) Runbooks

* **Falha na verificação da assinatura**
  Ação: bloquear aceitação no Z5; verificar cadeia OIDC/KMS; re-assinar; auditar quem acessou.
* **Attestation ausente/inconsistente**
  Ação: marcar versão como **INVALID**; exigir reexecução da etapa de build/treino com provenance.
* **Vulnerabilidade grave pós-registro**
  Ação: **REVOKED** no Z5; notificar Z6; acionar rollback; abrir incidente e SCDR.
* **Divergência entre pacote e metadados**
  Ação: rejeitar submissão; revisar pipeline; reforçar *schema* do pacote (JSON Schema assinado).

---

## 11) Frase pronta para a entrevista

> “Depois que o modelo passa por higiene e testes adversariais, **empacotamos** pesos, configs e evidências; geramos **SBOM**, **checksums**, **assinamos** os artefatos e emitimos **attestations** (SLSA/in-toto). Só então **submetemos ao Registry** que valida **assinatura, proveniência e políticas**. Em produção (Z6), **reverificamos** as assinaturas e recusamos versões **revogadas**. Sem **evidência + assinatura**, **não tem deploy**.”
