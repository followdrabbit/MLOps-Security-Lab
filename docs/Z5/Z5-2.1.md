# Z5-2.1 — **Registry Core (catálogo de modelos)**

*“a única fonte de verdade para versões de modelo, metadados e evidências”*

---

## 1) Papel & Objetivo

O **Registry Core** é o serviço que **registra**, **versiona** e **serve metadados imutáveis** dos modelos. Ele guarda **o que** (artefatos), **de onde** (proveniência), **em que condições** (evidências/controles) e **em que estado** (Candidate/Staging/Approved/Revoked) cada versão está.
Sem “passar pelo registry”, **não existe produção**.

---

## 2) Entidades & Objetos (vista lógica)

* **Model**: nome lógico (ex.: `risk-default`).
* **Model Version**: `name:version` + `digest` (imutável).
* **Artifacts**: pesos/configs/manifestos (ex.: `model.onnx`, `inference_config.yaml`, `checksums.json`).
* **Evidence**: relatórios (higiene, adversarial, fairness), **SBOM**, **cosign sig**, **attestation** (SLSA/in-toto).
* **Policy Snapshot**: *hash* das políticas aplicáveis em Z6 (AuthZ, LLM guardrails, output limits).
* **States**: `Candidate` → `Staging` → `Approved` → `Revoked` (e opcional `Quarantined`).

---

## 3) Metadados obrigatórios por **Model Version**

> Rejeitar submissões sem estes campos (gate automático).

| Campo                         | Descrição                           | Exemplo                    |
| ----------------------------- | ----------------------------------- | -------------------------- |
| `model_name`                  | Nome lógico                         | `risk-default`             |
| `version`                     | Tag legível (além do digest)        | `v2.3.0`                   |
| `artifact_digest`             | SHA256 do pacote/arquivo principal  | `sha256:…`                 |
| `run_id`                      | Execução no tracker (MLflow)        | `b7e…`                     |
| `git_sha`                     | Commit do código de treino          | `9a1c…`                    |
| `container_digest`            | Imagem do *train/runtime*           | `sha256:…`                 |
| `dataset_snapshot`            | ID/URI + carimbo temporal           | `s3://…@2025-11-12T19:30Z` |
| `sbom_ref`                    | Local do SBOM                       | `artifacts/sbom/spdx.json` |
| `cosign_sig`                  | Assinatura do artefato              | `signatures/model.sig`     |
| `attestation_ref`             | Proveniência SLSA/in-toto           | `intoto/provenance.json`   |
| `security_decision`           | Resultado 2.5 (PASS/FAIL)           | `PASS`                     |
| `model_card_url`              | Card final                          | `artifacts/model_card.md`  |
| `scdr_id` / `adr_id`          | Decisões de segurança/arquitetura   | `BANK.ML…` / `ADR-012`     |
| `policy_digest`               | Hash do snapshot de políticas da Z6 | `a1b2…`                    |
| `stage`                       | Estado atual                        | `Candidate`                |
| `created_by` / `approved_by`  | Identidades (SoD)                   | `sec_ops_bot` / `maria.s`  |
| `tags.privacidade.finalidade` | Finalidade LGPD                     | `concessão de crédito`     |

---

## 4) Imutabilidade & Versionamento

* **Imutável por definição**: alterar qualquer artefato ⇒ **nova versão**.
* **Identidade forte**: `artifact_digest` (conteúdo) + `version` (semver/semântico).
* **Aliases** (opcional): `production` aponta para a versão **Approved** vigente (auditável).
* **Retenção**: política WORM/“object lock” para artefatos e metadados críticos.

---

## 5) Estados & Transições (somente via pipeline)

* `Candidate` (entrada no catálogo): já **verifica assinatura/attestation** e campos obrigatórios.
* `Staging` (testes integrados/produção-like): exige **gates PASS** de readiness.
* `Approved` (consumo pela Z6): *four-eyes*, **policy snapshot** vinculado, canary/staging OK.
* `Revoked` (bloqueado): consumo proibido; **purga de cache** na Z6.
* `Quarantined` (opcional): sob investigação (CVE, comportamento anômalo).

---

## 6) Acesso & Tenancy

* **Papéis mínimos** (RBAC):

  * *Registrar* (cria `Candidate`), *Promoter* (transiciona estados), *Consumer* (leitura/resolve), *Auditor* (somente leitura/auditoria), *Admin* (gestão).
* **ABAC**: restrições por `tenant`, `domínio`, `ambiente` (dev/stage/prod) e `modelo`.
* **SoD**: quem registra **não** aprova; quem aprova **não** administra chaves.

---

## 7) Auditoria & Trilhas

* Registrar **quem/quando**: criou versão, alterou `stage`, vinculou `policy_digest`.
* Registrar **verificações**: resultado de cosign/attestation/OPA; CRL/rekor consultados.
* Enviar eventos a **Z9**: `model_submitted`, `promotion`, `revocation`, `download_verified`.

---

## 8) Integrações essenciais

* **Z4 → Z5**: submissão do pacote **assinado** + evidências.
* **Z6 ← Z5**: *startup* e *download* **reverificam** assinatura/attestation e `policy_digest`.
* **Z8** (Vault/KMS): chaves de assinatura, rotação; IdP para RBAC.
* **Z9**: dashboards *per-version* + alertas (drift, latência, erro) vinculados à versão.

---

## 9) Boas práticas de armazenamento

* Artefatos em **objeto storage** com **cripto em repouso** (KMS) e **WORM** para *evidence*.
* Banco de metadados com **backup/DR** e **migrations** versionadas.
* **Checksums** de tudo que é baixado; **tamanho máximo** e **tipos permitidos** versionados.

---

## 10) Operações comuns (MLflow — exemplos didáticos)

### 10.1 Registrar um modelo e criar versão

```python
import mlflow
from mlflow.tracking import MlflowClient

client = MlflowClient()
# garante existência do "registered model"
try:
    client.create_registered_model("risk-default")
except Exception:
    pass

mv = client.create_model_version(
    name="risk-default",
    source=f"{run.info.artifact_uri}/model",  # caminho do artefato no run
    run_id=run.info.run_id,
)

# tags obrigatórias (metadados do §3)
client.set_model_version_tag("risk-default", mv.version, "artifact_digest", ARTIFACT_SHA256)
client.set_model_version_tag("risk-default", mv.version, "git_sha", GIT_SHA)
client.set_model_version_tag("risk-default", mv.version, "dataset_snapshot", SNAPSHOT_ID)
client.set_model_version_tag("risk-default", mv.version, "sbom_ref", "artifacts/sbom/spdx.json")
client.set_model_version_tag("risk-default", mv.version, "cosign_sig", "signatures/model.sig")
client.set_model_version_tag("risk-default", mv.version, "attestation_ref", "intoto/provenance.json")
client.set_model_version_tag("risk-default", mv.version, "security_decision", "PASS")
client.set_model_version_tag("risk-default", mv.version, "policy_digest", POLICY_SHA256)
```

### 10.2 Transicionar estado (com gate externo já aprovado)

```python
client.transition_model_version_stage(
    name="risk-default",
    version=mv.version,
    stage="Staging",  # depois Approved
    archive_existing_versions=False
)
```

### 10.3 Resolver versão **Approved** para servir (Z6)

```python
prod = client.get_latest_versions("risk-default", stages=["Approved"])[0]
print(prod.version, prod.tags["artifact_digest"], prod.tags["policy_digest"])
```

---

## 11) Conformidade (mapeamento de referência)

* **NIST SSDF / SLSA**: proveniência/attestation e cadeia de suprimentos.
* **NIST SP 800-53 (SA-, CM-, AC-, AU-)**: aceite controlado, configuração, acesso e auditoria.
* **CSA CCM**: IAM, LOG, SEF; **AICM** para IA (governança/operacional).
* **ISO/IEC 23894** (IA) e **LGPD/GDPR** (finalidade/base legal) via *tags* obrigatórias no registro.

---

## 12) Checklist (aceitação mínima no `Candidate`)

* [ ] `cosign_sig` válida (cadeia OIDC/KMS)
* [ ] `attestation_ref` presente e coerente (`git_sha`, `container_digest`, `dataset_snapshot`)
* [ ] `security_decision=PASS` (Z4-2.5)
* [ ] `sbom_ref` sem **CVE bloqueadora**
* [ ] `model_card_url`, `scdr_id`, `adr_id` preenchidos
* [ ] `policy_digest` calculado (mesmo que **provisional** para Staging)
* [ ] Todos os **hashes** em `checksums.json` conferem

---

## 13) Runbooks (falhas comuns)

* **Assinatura inválida** → rejeitar; verificar relógio/issuer OIDC/KMS; re-assinar artefatos.
* **Attestation ausente** → rejeitar; reexecutar pipeline com in-toto/SLSA.
* **SBOM com CVE crítica** → bloquear; abrir *work item* para correção/mitigação; reempacotar.
* **Policy mismatch no download** → Z6 bloqueia startup; republicar **policy snapshot** com *hash* correto.

---

## 14) Frase pronta (entrevista)

> “No **Registry Core** cada versão é **imutável**, **assinada** e vinculada a **proveniência**, **SBOM** e **decisões de governança**. Estados e promoções são **policy-as-code** e somente via pipeline. A Z6 só carrega versões **Approved/Staging** cuja assinatura/attestation e `policy_digest` batem — caso contrário, o *startup* é bloqueado.”
