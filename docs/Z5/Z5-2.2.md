# Z5-2.2 — **Verificação de Assinaturas & Attestations**

*“sem **assinatura válida** e **proveniência checada**, o Registry não aceita nem entrega nada”*

---

## 1) Objetivo

Garantir **integridade**, **autenticidade** e **proveniência** dos modelos e seus artefatos antes de:

* **Entrarem** no catálogo (upload → `Candidate`), e
* **Saírem** para o serving (download/startup da Z6).

Isso fecha o elo da **cadeia de suprimentos** (code→build→train→package→registry→serve).

---

## 2) O que é verificado (checklist mínimo)

1. **Assinatura criptográfica** dos artefatos:

   * Arquivo de modelo (`.onnx`, `.pt`, etc.)
   * Manifesto de *checksums* (`checksums.json`)
   * (Se aplicável) **imagem** do *runtime* de inferência (por **digest**)
2. **Attestation de proveniência** (*in-toto/SLSA*):

   * *builder id*, *buildType*, **`git_sha`**, **`container_digest`**,
   * **`dataset_snapshot`**, *params/seed*, **timestamps**.
3. **Checksums e tamanhos** (anti-corrupção/alteração parcial)
4. **Revogação/expiração**:

   * Chaves/tokens não revogados; validade temporal (*notBefore/notAfter*),
   * Registro no **transparency log** (ex.: Rekor) ou *bundle* de verificação offline.
5. **Coerência** entre **attestation**, **SBOM**, **tags** do Registry e **run**:

   * `git_sha`, `container_digest`, `dataset@snapshot`, `sbom_ref`.

> Política: **qualquer** discrepância bloqueia o aceite/consumo.

---

## 3) Fluxos: **Entrada** (upload) vs **Saída** (download/startup)

### 3.1 Entrada (upload → `Candidate`)

1. Receber pacote com: artefatos + `checksums.json` + **assinaturas** + **attestation** + **SBOM**.
2. **Verificar assinaturas** (cosign) dos artefatos principais e/ou imagem.
3. **Validar attestation** (in-toto/SLSA): *subject digest* bate com o arquivo; `git_sha/container/dataset`.
4. Conferir **checksums** e tamanhos.
5. Checar **revogação/validade** de chave (KMS/HSM/Keyless OIDC + Rekor).
6. Se tudo **OK** → cria `Model Version` **`Candidate`**; se **FAIL** → rejeitar com motivo.

### 3.2 Saída (Z6 startup/download)

1. Z6 solicita `name:version`.
2. Registry retorna **metadados** e **policy_digest** associado.
3. Z6 **reverifica** assinatura/attestation e se **não está `Revoked`**.
4. Z6 valida `policy_digest` == `policy_snapshot` local.
5. Se **OK** carrega; se **FAIL** bloqueia *startup* e registra evento em Z9.

> **Defesa em profundidade**: verificação **dupla** (na entrada e no consumo).

---

## 4) Assinatura: padrões & chaves

### 4.1 Ferramenta/prática recomendada

* **cosign** (sigstore) para:

  * **sign-blob** (arquivos de modelo/manifestos),
  * **sign** por **digest** para **imagens** (runtime de inferência),
  * **verify** e **verify-attestation**.

### 4.2 Gestão de chaves

* **Keyless OIDC** (fulcio/rekor) **ou** chaves em **KMS/HSM** (rotação + SoD).
* **Rotação** planejada; **CRL**/**revocation list** mantida.
* **Bundles offline** (cosign) caso Rekor esteja indisponível.

> Política: assinatura **forte**, com **cadeia validada** e **registro de transparência** quando possível.

---

## 5) Attestation (in-toto / SLSA)

* Documento assinado que declara **como** o artefato foi produzido.
* Campos mínimos úteis no lab:

  * `subject.digest.sha256` do arquivo de modelo,
  * `builder.id` (ex.: GitHub Actions workflow/runner),
  * `buildType` (ex.: `ml-train-pipeline@v1`),
  * `invocation.configSource.digest.gitSha`,
  * `parameters` (seed, *hyperparams*),
  * `metadata.buildStartedOn/buildFinishedOn`,
  * **`container_digest`** do ambiente de treino,
  * **`dataset_snapshot`** (URI + timestamp).
* **Verificação**:

  * A *subject digest* aponta para **exatamente** o arquivo que você está aceitando,
  * *Builder* e `git_sha` batem com as **tags** do `Model Version`,
  * `dataset_snapshot` confere com o **catálogo de dados**.

---

## 6) Políticas (Policy-as-Code) — exemplos

### 6.1 Gate de **entrada** (`accept`)

```rego
package registry.accept

default allow = false

allow {
  input.signatures.model_valid
  input.signatures.checksums_signed
  input.attestation.present
  input.attestation.subject_sha256 == input.artifact.sha256
  input.attestation.git_sha == input.meta.git_sha
  input.attestation.container_digest == input.meta.container_digest
  input.attestation.dataset_snapshot == input.meta.dataset_snapshot
  not input.sbom.has_blocking_cves
  time.now_ns() >= input.attestation.not_before_ns
  time.now_ns() <= input.attestation.not_after_ns
}
```

### 6.2 Gate de **download/startup** (Z6)

```rego
package registry.download

default permit = false

permit {
  input.stage in {"Staging","Approved"}
  input.signatures.model_valid
  input.attestation.present
  not input.revoked
  input.policy_digest == input.runtime.policy_digest
}
```

---

## 7) Implementação sugerida (Lab)

### 7.1 Verificar assinatura de **arquivo** (cosign)

```bash
cosign verify-blob --signature signatures/model.sig model/model.onnx
```

### 7.2 Verificar assinatura de **imagem** (por digest)

```bash
cosign verify --key cosign.pub registry.corp/ml-serving@sha256:ABCDEF...
```

### 7.3 Verificar **attestation** (resumo)

```bash
cosign verify-attestation --type slsaprovenance \
  registry.corp/models/risk-default@sha256:... > attestation.json

# conferir campos esperados (pseudo)
jq -e '
  .predicate.buildType=="ml-train-pipeline@v1" and
  .subject[0].digest.sha256=="'"$ARTIFACT_SHA256"'" and
  .predicate.invocation.configSource.digest.gitSha=="'"$GIT_SHA"'" and
  .predicate.metadata.buildStartedOn!=null
' attestation.json
```

### 7.4 Conferir **checksums**

```bash
jq -r '.files[] | "\(.sha256)  \(.path)"' checksums.json | sha256sum -c -
```

### 7.5 Verificação **offline** com *bundle*

```bash
cosign verify-blob --bundle signatures/model.sig.bundle model/model.onnx
```

---

## 8) Riscos × Controles × Frameworks

| Risco                                              | Controles (Z5-2.2)                                                                          | Referências                          |
| -------------------------------------------------- | ------------------------------------------------------------------------------------------- | ------------------------------------ |
| **Artefato trocado** (man-in-the-middle/alteração) | Assinatura cosign de arquivo/manifest + verificação de **digest**                           | NIST SP 800-53 SI-7, CM-5; NIST SSDF |
| **Build não confiável**                            | **Attestation** (in-toto/SLSA) vinculando `git_sha`, `container_digest`, `dataset_snapshot` | SLSA L3+, SSDF, ISO/IEC 27001 A.8    |
| **Chave comprometida/expirada**                    | KMS/HSM ou **Keyless OIDC** + **revogação** (CRL/Rekor) + rotação                           | NIST SC-12/SC-13, CSA CCM (IAM/KEY)  |
| **Uso de versão revogada**                         | Flag `Revoked` + verificação no **download/startup**                                        | NIST SI-4; CSA AICM (SEF/LOG)        |
| **Divergência de políticas**                       | `policy_digest` obrigatório e checado no *startup*                                          | NIST CM-6/CM-7; OWASP ML/LLM         |

---

## 9) Runbooks (falhas típicas)

* **“Assinatura inválida”**
  *Ação:* rejeitar; validar relógio/NTP; conferir issuer OIDC; re-assinar; revisar `cosign.pub`/verificador.

* **“Attestation não confere com metadados”**
  *Ação:* bloquear; comparar `git_sha/container_digest/dataset_snapshot`; reexecutar pipeline de treino.

* **“Transparência indisponível (Rekor down)”**
  *Ação:* exigir **bundle**; permitir modo *degraded* com aprovação humana; registrar SCDR.

* **“Versão revogada foi baixada”**
  *Ação:* Z6 deve bloquear *startup* e limpar cache; investigar por que *cache warming* não respeitou estado.

* **“SBOM com CVE crítica”**
  *Ação:* reempacotar/atualizar dependências; documentar exceção temporária via SCDR com prazo.

---

## 10) Frase pronta (entrevista)

> “No Registry eu **não** aceito nem sirvo modelos sem **assinatura válida** e **attestation de proveniência**. Verifico **cosign** em arquivos e imagens, **in-toto/SLSA** para `git_sha/container/dataset`, **checksums**, **revogação** e **policy_digest**. Repito essas checagens **no download**: se algo não bate, a Z6 **bloqueia o startup**. Esse é o pilar de **supply chain** do meu MLOps.”
