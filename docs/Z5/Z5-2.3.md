# Z5-2.3 — **Policy Engine & Gates (Policy-as-Code)**

*“promoção e consumo só acontecem quando as **regras objetivas** dizem SIM — e isso deixa trilha”*

---

## 1) Objetivo & Princípios

**Objetivo:** transformar os critérios de segurança, risco, qualidade e conformidade em **políticas executáveis** (OPA/Rego) que decidem: **aceitar**, **promover**, **servir**, **revogar** ou **quarentenar** versões de modelo no Registry.

**Princípios**

* **Automatizar primeiro** (Rego), **duas pessoas aprovam** depois (*four-eyes*).
* **Evidência vinculada**: decisão só passa se os artefatos e comprovações estão anexados.
* **Imutabilidade e reprodutibilidade**: decisão referencia *hashes* (artefato, SBOM, políticas).
* **Tempo limitado para exceções**: *waivers* com TTL e motivo explícito (SCDR).
* **Auditoria completa**: *decision logs* com *input snapshot* (sem PII) e *policy_digest*.

---

## 2) Arquitetura lógica (onde as políticas atuam)

1. **Accept Gate (Upload → `Candidate`)**
   Webhook do Registry chama OPA: valida **assinaturas**, **attestation**, **SBOM**, **higiene** e **metas mínimas**.

2. **Promotion Gates (`Candidate→Staging` e `Staging→Approved`)**
   Pipelines de promoção executam OPA; exigem **Readiness PASS**, **Canary PROCEED**, **policy snapshot** vinculado e *four-eyes*.

3. **Download/Startup Gate (Z6)**
   No *startup*/refresh de um *serving*, OPA checa **stage permitido**, **assinaturas**, **attestation**, **não revogado**, **policy_digest** igual ao **runtime**.

4. **Continuous Gates (pós-produção)**
   Jobs de compliance avaliam **expiração** (revalidação/fairness), **drift**, **incidentes** e podem **demover** (`Approved→Quarantined/Revoked`).

---

## 3) Esquema de **entrada** do OPA (exemplo)

```json
{
  "meta": {
    "model_name": "risk-default",
    "version": "v2.3.0",
    "run_id": "b7e...",
    "stage_from": "Staging",
    "stage_to": "Approved",
    "now_ts": "2025-11-12T23:10:00Z"
  },
  "signatures": {
    "model_valid": true,
    "checksums_signed": true
  },
  "attestation": {
    "present": true,
    "subject_sha256": "sha256:...",
    "git_sha": "9a1c...",
    "container_digest": "sha256:...",
    "dataset_snapshot": "s3://...@2025-10-28T20:00Z",
    "not_before_ns": 1690000000000000000,
    "not_after_ns": 1790000000000000000
  },
  "sbom": {
    "present": true,
    "has_blocking_cves": false
  },
  "readiness": {
    "security_decision": "PASS",
    "fairness_ok": true,
    "metrics": {"auc": 0.86, "latency_p95_ms": 95}
  },
  "canary": {"result": "PROCEED"},
  "policies": {"bound": true, "policy_digest": "a1b2..."},
  "privacy": {"finalidade": "concessao_credito", "base_legal": "consentimento"},
  "lifecycle": {"revalidate_by": "2026-02-10"}
}
```

> Padronize esse *input schema* nos pipelines para que as mesmas policies sirvam a todos os gates.

---

## 4) Conjunto de **Gates padrão** (o que cada um exige)

| Gate                 | Momento            | Exige (exemplos)                                                                                              | Bloqueia quando                                           |
| -------------------- | ------------------ | ------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------- |
| **Accept**           | Upload→`Candidate` | `signatures.model_valid`, `attestation.present`, `sbom.present` sem CVE bloqueadora, `security_decision=PASS` | Assinatura inválida, attestation incoerente, SBOM crítico |
| **Promote→Staging**  | Pré-Staging        | Readiness parcial, `policy_digest` provisório, *four-eyes* (Produto+Segurança)                                | Falta *evidence*, fairness fail                           |
| **Promote→Approved** | Pós-Canary         | `canary.result=PROCEED`, `policies.bound=true`, *four-eyes*, janela de revalidação definida                   | Canary reprovado, políticas não vinculadas                |
| **Download/Startup** | Z6 startup/refresh | `stage ∈ {Staging,Approved}`, assinatura/attestation válidas, **não revogado**, `policy_digest` bate          | Revogado, mismatch de políticas                           |
| **Expiry/Review**    | Diário             | `revalidate_by` vencido → alerta/hold                                                                         | Versão expirada                                           |
| **Incident/Drift**   | Evento             | Drift acima do limiar, incidente de segurança/privacidade                                                     | Demove para `Quarantined`/`Revoked`                       |

---

## 5) **Exceções controladas** (waivers) via SCDR

* **Quando**: CVE sem correção imediata, *edge case* de fairness, dependência temporária.
* **Como**: criar SCDR com **risco residual**, **mitigações**, **prazo (TTL)** e **responsáveis**.
* **No Rego**: *waiver* expira por tempo ou condição — ao expirar, gate volta a **bloquear**.

```rego
package registry.waiver

waiver_active {
  input.waiver.present
  time.now_ns() < input.waiver.expires_ns
}
```

---

## 6) Versionamento & **assinatura** de políticas

* **Policy Snapshot**: conjunto de arquivos (`policies/*.rego`, `policies/*.yaml`) empacotado e **assinado** (cosign).
* Calcule `policy_digest` (SHA256) e **grave** como *tag* da versão no Registry.
* O *startup* na Z6 compara `policy_digest (registry)` **vs** `policy_digest (runtime)` — divergência **bloqueia**.

```bash
tar -cf policy_snapshot.tar policies/
sha256sum policy_snapshot.tar | cut -d' ' -f1 > policy.sha256
cosign sign-blob --output-signature policy.sig policy_snapshot.tar
```

---

## 7) Observabilidade & Auditoria

* **Decision logs** do OPA habilitados (com *redaction*).
* **Event bus** para Z9: `model_submitted`, `policy_allow/deny`, `promotion`, `revocation`.
* **Inputs resumidos** (hash/IDs, nunca PII) anexados ao *run* no MLflow.

---

## 8) Policies Rego — **exemplos práticos**

### 8.1 **Accept** (entrada no catálogo)

```rego
package registry.accept
default allow = false
allow {
  input.signatures.model_valid
  input.signatures.checksums_signed
  input.attestation.present
  input.attestation.subject_sha256 == input.artifact.sha256
  input.attestation.git_sha == input.meta.git_sha
  not input.sbom.has_blocking_cves
  input.readiness.security_decision == "PASS"
  input.privacy.finalidade != ""
  input.privacy.base_legal != ""
}
```

### 8.2 **Promotion: Staging → Approved**

```rego
package registry.promote
default allow = false
allow {
  input.meta.stage_from == "Staging"
  input.meta.stage_to   == "Approved"
  input.canary.result == "PROCEED"
  input.policies.bound
  input.signatures.model_valid
  time.now_ns() <= time.parse_rfc3339_ns(input.lifecycle.revalidate_by)
}
```

### 8.3 **Download/Startup (Z6)**

```rego
package registry.download
default permit = false
permit {
  input.stage == "Approved"  # ou "Staging" em ambientes controlados
  input.signatures.model_valid
  input.attestation.present
  not input.revoked
  input.policies.policy_digest == input.runtime.policy_digest
}
```

### 8.4 **Incident/Drift Gate** (continuidade)

```rego
package registry.runtime_guard
default allow = true
deny_reason["drift"] {
  input.monitoring.drift_psi > 0.2
}
deny_reason["error_rate"] {
  input.monitoring.error_rate > 0.01
}
allow { count(deny_reason) == 0 }
```

---

## 9) Integração no **pipeline** (esqueleto)

```yaml
jobs:
  accept:
    steps:
      - run: opa eval -i input.accept.json -d policies 'data.registry.accept.allow'
  promote_staging:
    steps:
      - run: opa eval -i input.promote_staging.json -d policies 'data.registry.promote.allow'
  promote_approved:
    steps:
      - run: opa eval -i input.promote_approved.json -d policies 'data.registry.promote.allow'
      - run: ./four_eyes_approval.sh  # dupla aprovação humana
  startup_check_z6:
    steps:
      - run: opa eval -i input.download.json -d policies 'data.registry.download.permit'
```

---

## 10) Riscos × Controles × Frameworks

| Risco                          | Controles (este item)                                                          | Referenciais                           |
| ------------------------------ | ------------------------------------------------------------------------------ | -------------------------------------- |
| Promoção sem evidências        | **Accept/Promotion Gates** com OPA, *four-eyes*, SCDR                          | NIST AI RMF (Govern/Manage), NIST SSDF |
| Quebra de conformidade (LGPD)  | Campos obrigatórios de **finalidade/base legal** no *input*, *deny* se ausente | LGPD/GDPR, CSA CCM (DSI/IAM)           |
| Drift e regressões em produção | **Runtime gates** + *incident/drift* policies e demotion                       | SRE/SLO, OWASP ML/LLM                  |
| Desalinhamento de políticas    | **policy_snapshot** assinado + `policy_digest` no startup                      | NIST CM-6/CM-7                         |
| Mudança não auditável          | **Decision logs** + eventos Z9 + *input snapshot*                              | NIST AU-2/AU-12                        |

---

## 11) Runbooks (quando o gate **nega**)

* **Falha em Accept**: revisar assinatura/attestation/SBOM; reempacotar; anexar evidências que faltam.
* **Falha em Promote→Approved**: verificar `canary.result`, `policy_digest`, `revalidate_by`; coletar *approvals*.
* **Startup bloqueado**: mismatch de `policy_digest` ou versão **revogada** → recarregar snapshot, limpar cache, auditar.
* **Drift gate acionado**: reduzir tráfego, acionar playbook de recalibração/retreino, abrir SCDR.

---

## 12) Frase pronta (entrevista)

> “No Registry eu codifico critérios em **Rego**. Há **gates** para **aceitar**, **promover** e **servir**: eles checam assinaturas, **attestation**, **SBOM**, **Readiness/Canary**, LGPD e **policy_snapshot**. As decisões deixam **trilha** e exigem **four-eyes**. Em produção, um *startup gate* compara `policy_digest`; se algo não bate ou há **drift/incident**, o gate **demove** a versão. Sem **Policy-as-Code**, ninguém promove ou carrega nada.”
