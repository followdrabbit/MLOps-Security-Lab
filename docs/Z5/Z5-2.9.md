# Z5-2.9 — **Integridade de Download (para Z6)**

*“o serviço de serving **só inicia** se o que ele baixar do Registry for autêntico, íntegro, permitido e em conformidade com a policy em vigor.”*

---

## 1) Objetivo & Escopo

Garantir, **no momento do startup/refresh da Z6**, que **apenas** versões de modelo devidamente **verificadas** sejam carregadas, bloqueando qualquer desvio de cadeia de suprimentos ou de governança.

**Regra dura:** Z6 só carrega `stage ∈ {"Staging","Approved"}` **E**:

* **assinatura válida** do artefato (cosign/KMS)
* **attestation presente** e coerente (in-toto/SLSA)
* `policy_digest` do **runtime** = `policy_digest` do **Registry**
* **não revogado / não quarentenado**
* (opcional, recomendado) **tenant/purpose** do *token* batem com o Model Card

Falha em qualquer verificação ⇒ **bloqueia startup** e registra evento.

---

## 2) O que é verificado no startup (checklist mínimo)

1. **Autorização de acesso** (token OIDC curto-vivo, mTLS)
2. **Resolução por alias** (ex.: `production` → `name@version`) **pelo digest**
3. **Stage permitido** (`Staging` em ambientes controlados / `Approved` em prod)
4. **Revogação/Quarentena**: `revoked=false` **e** `quarantined=false`
5. **Assinaturas** dos **arquivos de modelo** (ex.: `.onnx/.pt`) e/ou **imagem** de runtime por **digest**
6. **Attestation**: `subject.sha256` = SHA do arquivo; `git_sha`, `container_digest`, `dataset_snapshot` coerentes
7. **Policy-as-Code**: `policy_digest(runtime)` == `policy_digest(registry)`
8. **Validades**: *notBefore/notAfter* da attestation, `revalidate_by` do Model Card
9. **Tenancy & Purpose** (ABAC): `tenant_id`, `domain`, `purpose.allowed` compatíveis com o *token* do serviço

---

## 3) Fluxo de **startup/refresh** (passo a passo)

1. **Z6** obtém **token OIDC** (workload identity) e abre conexão **mTLS** com o Registry.
2. Resolve **alias** ou versão solicitada → recebe metadados (`stage`, `artifact_digest`, `policy_digest`, flags de `revoked/quarantined`).
3. **Nega** imediatamente se `revoked/quarantined=true` ou `stage` fora da política do ambiente.
4. **Baixa** o artefato por **digest** + *bundle* de assinatura/attestation (ou **verifica por referência** se já em cache).
5. **Verifica**:

   * cosign **verify-blob / verify** (arquivo/imagem)
   * cosign **verify-attestation** (in-toto → `subject.digest`, `git_sha`, `container_digest`, `dataset_snapshot`)
   * **`policy_digest`** recebido **=** *snapshot* local
6. Se **tudo OK**: faz **load** do modelo, aplica *limits/guardrails* e registra **evento de sucesso**.
7. Se **FAIL**: **não inicia** ou **faz rollback** para versão anterior saudável, emite alerta e logs (Z9).

---

## 4) Exigências técnicas (como implementar)

### 4.1 Verificação de **assinatura** do arquivo

```bash
# arquivo do modelo
cosign verify-blob \
  --signature /opt/models/signatures/model.sig \
  /opt/models/model.onnx
```

### 4.2 Verificação de **assinatura** da imagem (serving)

```bash
# runtime por digest (admission control já deve exigir isso no cluster)
cosign verify --key cosign.pub \
  registry.corp/serving@sha256:ABCDEF...
```

### 4.3 Verificação de **attestation** (resumo)

```bash
cosign verify-attestation --type slsaprovenance \
  registry.corp/models/risk-default@sha256:... > attestation.json

jq -e '
  .subject[0].digest.sha256 == env:ARTIFACT_SHA256 and
  .predicate.invocation.configSource.digest.gitSha == env:GIT_SHA and
  .predicate.materials[]?.digest.sha256? == env:CONTAINER_DIGEST
' attestation.json
```

### 4.4 **Policy snapshot** (coerência runtime↔registry)

* Calcular `policy_digest` do pacote de políticas no **deploy** (Z6) e compará-lo com o `policy_digest` da versão no **Registry**.
* Divergência ⇒ **bloqueia** startup (evita “servir com policy antiga”).

---

## 5) Política de **permit** (OPA/Rego — exemplo)

```rego
package registry.download

default permit = false

permit {
  input.stage == "Approved"                                  # ou "Staging" (não-prod)
  not input.revoked
  not input.quarantined
  input.signatures.model_valid
  input.attestation.present
  input.attestation.subject_sha256 == input.artifact.sha256
  input.policies.policy_digest == input.runtime.policy_digest
  input.requester.tenant_id == input.resource.tenant_id
  some p; p := input.requester.purpose[_]                    # propósito permitido (LGPD)
  p == input.model_card.purpose.allowed[_]
  time.now_ns() <= time.parse_rfc3339_ns(input.lifecycle.revalidate_by)
}
```

---

## 6) Cache & Supply Chain (defesa em profundidade)

* **Pin por digest** (nunca por `:latest`).
* **Cache local** com **reverificação** (assinatura/attestation) a cada carregamento.
* **Bundles offline** (cosign) para “modo degradado” caso Rekor esteja indisponível — ainda assim **bloquear** se attestation/assinatura falhar.
* **Allowlist** de registries/URLs; **TLS 1.2+** obrigatório; **mTLS** entre Z6↔Registry.
* **Clock sync** (NTP): invalidez temporal invalida *tokens* e *attestations*.
* **Anti-downgrade**: não aceitar versão **mais antiga** do que a atual **sem** mudança explícita de alias/change ticket.

---

## 7) Endurecimento do runtime (Z6)

* **Read-only FS**, **runAsNonRoot**, `seccomp/AppArmor` estritos.
* **NetworkPolicies**: apenas Registry, observabilidade e dependências explícitas.
* **Sem egress aberto** para internet (reduz exfiltração).
* **Secrets** só via **Vault Agent**/workload identity; **zero** segredos estáticos.
* **FIPS-compatible crypto** quando aplicável.

---

## 8) Logs, métricas & auditoria (Z9)

Registrar sempre (sem PII):

* `model`, `version`, `artifact_digest`, `policy_digest`, `git_sha`, `container_digest`
* `decision` (permit/deny) e **motivo** (mismatch, assinatura inválida, revogado, etc.)
* `tenant/domain/env`, `caller` (workload), `latência` de verificação
* Eventos: `startup_permit`, `startup_deny`, `rollback_execute`

---

## 9) Falhas comuns & runbooks

* **`policy_digest` mismatch** → sincronizar *policy snapshot*, reexecutar gate.
* **Assinatura inválida** → checar chave pública, *bundle*, integridade do arquivo; **não** iniciar.
* **Attestation incoerente** (`git_sha/dataset`) → bloquear e acionar pipeline de *re-build*.
* **Revogado/Quarentenado** → **não** carregar; validar se purge foi feito; comunicar incidente.
* **Rekor/PKI indisponível** → aceitar **apenas** se *bundle* confiável estiver presente; do contrário, **bloquear**.

---

## 10) Testes de conformidade (pré-prod)

* **Chaos test**: simular `revoked=true` durante *warmup* → Z6 deve negar e voltar à versão anterior.
* **Negative tests**: alterar 1 byte do artefato → assinatura falha → startup negado.
* **Policy drift**: trocar *policy snapshot* no pod sem atualizar no Registry → `policy_digest` difere → negar.
* **Tenant cross**: *token* de tenant `A` tentando baixar modelo do tenant `B` → negar.

---

## 11) Mapeamento a frameworks

* **NIST SP 800-53**: SI-7 (integridade), SC-13 (criptografia), CM-5/CM-6 (config/política), AC-6 (least privilege).
* **NIST SSDF / SLSA**: verificação de proveniência e supply chain no consumo.
* **NIST AI RMF** (Manage/Measure): controles verificáveis no ciclo de vida.
* **CSA CCM**: **SEF** (segurança de serviços), **IAM**, **LOG**.

---

## 12) Frase pronta (entrevista)

> “Na Z6 eu **não carrego** modelo se qualquer verificação falhar: **assinatura** cosign válida, **attestation** in-toto coerente com `git_sha/container/dataset`, `stage` permitido, **não revogado/quarentenado**, e `policy_digest(runtime)=policy_digest(registry)`. Tudo via **mTLS + OIDC**, pin por **digest**, **anti-downgrade**, logs/auditoria em Z9. Se algo não bate, o startup **nega** e dispara **rollback** para a última `Approved` saudável.”
