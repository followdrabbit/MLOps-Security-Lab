# Z6-2.1 — Inference Gateway

*(API GW + WAF + AuthN/AuthZ, Rate Limiting, mTLS, Audit)*

## 1) Papel e posicionamento

O **Inference Gateway** é a **única porta de entrada** para inferência on-line de **modelos clássicos** (árvores, regressões, redes, etc.) publicados a partir da **Z5 (Prod Model Registry)**. Ele:

* **termina TLS** e aplica **mTLS** para tráfego serviço⇄serviço;
* **autentica e autoriza** clientes (apps internos, engines de risco, canais);
* impõe **rate limiting/quotas**, **WAF**, **validações de método/rota/cabeçalhos/corpo**;
* padroniza **erros** e **headers de segurança**;
* registra **logs/traços/métricas** e envia para Z9.

> Objetivo: blindar os serviços de modelo, garantir **contratos de API**, **identidade forte**, **controle de tráfego** e **rastreabilidade** ponta-a-ponta.

---

## 2) Capacidades obrigatórias

### 2.1 Ponto único + TLS/mTLS

* Um FQDN controlado (ex.: `infer.example.bank`) com **TLS 1.2+**.
* **mTLS** para chamadas internas (gateway→serviços de modelo, gateway→feature-store proxy).
* **Rotação de certificados** automática; chaves protegidas (Vault/KMS).

### 2.2 AuthN/AuthZ

* **OIDC/OAuth2** (client-credentials) para apps de backend; **JWT** validado (iss/aud/exp/nbf, assinatura).
* **mTLS com identidade atrelada** (cert-bound tokens / SAN por aplicação), quando sensível.
* **RBAC/ABAC** por **rota/versão/tenant** (ex.: `core-banking` só pode `/churn/v2/predict`).
* **Duração curta** de tokens; **revogação** e **lista de negação** ativas.
* **Nada** de credenciais estáticas no código—segredos via **Vault Agent**.

### 2.3 Rate limiting / Throttling / Quotas / Concurrency

* **Token bucket** por **identidade + rota**.
* **Burst** controlado; **concurrency limit** por cliente.
* **Quotas** por janela (min/h/dia) e **custo** (se aplicável).
* Respostas **429/503** consistentes + **Retry-After**.

### 2.4 WAF focado em API

* Regras contra **injection**, **path traversal**, **SSRF**, **JSON malformado**, **header abuse**.
* **Body inspection** para JSON (limite de tamanho e profundidade).
* **Anomaly score** e **bloqueio** para padrões suspeitos.

### 2.5 Validações de requisição e resposta

* **Métodos permitidos** por rota (ex.: `POST /v2/predict`).
* **Path allowlist** com *path params* validados (regex/constraints).
* **Content-Type** allowlist (`application/json`); **Content-Length** máximo.
* **Schema mínimo** (JSON Schema/pydantic) no gateway quando viável (camada 0) — a camada 1 é no serviço do modelo.
* **Resposta** com **schema básico** e **sanitização de campos sensíveis** (sem PII/segredos).

### 2.6 Resiliência e controle de tráfego

* **Timeouts** por upstream; **retries** com **backoff** **somente** para operações idempotentes.
* **Circuit breakers** (open/half-open/close) → proteção dos serviços.
* **Health-checks** e **outlier detection**; **load-balancing** (least-request, etc.).

### 2.7 Segurança de cabeçalhos e CORS

* **Security headers**: `Strict-Transport-Security`, `X-Content-Type-Options`, `X-Frame-Options`, `Referrer-Policy`, `Permissions-Policy`.
* **CORS** fechado; abrir **origens/métodos/headers** estritamente quando houver front-end browser.

### 2.8 Observabilidade e auditoria

* **Logs estruturados** (JSON): `request_id`, `correlation_id`, `tenant_id`, `client_id`, `subject`, `model`, `version`, `route`, `status`, `latency_ms`, `bytes_in/out`.
* **Sem PII** no log; **mascarar** tokens/segredos.
* **Métricas**: p50/p95/p99, taxa de erro, saturação, 4xx/5xx por rota/cliente.
* **Tracing** distribuído (propaga `traceparent` / `b3`).
* Envio para **Z9**.

### 2.9 Política de versões e *kill switch*

* **Versionamento** explícito em rota (`/v1`, `/v2`).
* **Bloqueio** de versões revogadas.
* **Kill switch** por versão/cliente (feature-flag) para rollback rápido.

---

## 3) Fluxo de referência (on-line)

1. **Cliente** (app interno / engine) chama `POST /<model>/<version>/predict` no **Inference Gateway**.
2. Gateway faz **TLS**, valida **JWT/mTLS**, aplica **WAF**, **rate limit**, valida **método/path/content-type/tamanho**.
3. Encaminha via **mTLS** ao **serviço do modelo Vn**.
4. Serviço valida **schema**, executa predição; retorna **resposta padronizada**.
5. Gateway adiciona **headers de segurança**, **mascara** campos sensíveis se necessário, registra **logs/métricas/trace**; responde ao cliente.

---

## 4) Políticas de autorização — exemplos (conceito)

### 4.1 ABAC por rota/versão/tenant (pseudo-Rego)

```rego
package serving.authz
default allow = false

allow {
  input.client_id == "core-banking"
  input.tenant == "retail"
  input.route == "/churn/v2/predict"
  input.model == "churn"
  input.version == "v2"
  input.scopes[_] == "predict:churn"
}
```

### 4.2 *Circuit breaker* por erro agregado

```rego
package serving.circuit
default open = false

open {
  input.model == "churn"
  input.version == "v2"
  input.error_rate_percent >= 8
  input.window_minutes <= 5
}
```

---

## 5) Exemplos práticos de config (resumo)

### 5.1 Traefik (estática — trechos)

```yaml
entryPoints:
  websecure:
    address: ":443"

api:
  dashboard: false

serversTransport:
  insecureSkipVerify: false  # checar TLS interno

# Rate limit (middleware)
http:
  middlewares:
    rl_churn_v2:
      rateLimit:
        average: 200
        burst: 50

    security-headers:
      headers:
        stsSeconds: 31536000
        stsIncludeSubdomains: true
        stsPreload: true
        frameDeny: true
        contentTypeNosniff: true
        referrerPolicy: "no-referrer"
        permissionsPolicy: "geolocation=(), microphone=(), camera=()"

  routers:
    churn_v2:
      rule: "PathPrefix(`/churn/v2/`)"
      entryPoints: ["websecure"]
      middlewares: ["rl_churn_v2", "security-headers"]
      service: "churn_v2_svc"
      tls:
        passthrough: false
```

### 5.2 Nginx (JWT + limites — trechos)

```nginx
limit_req_zone $binary_remote_addr zone=rl_churn:10m rate=200r/s;

server {
  listen 443 ssl http2;
  server_name infer.example.bank;

  # TLS config ...

  location /churn/v2/predict {
    limit_req zone=rl_churn burst=50 nodelay;
    client_max_body_size 512k;
    proxy_set_header X-Request-Id $request_id;

    # JWT validation via auth_request/sidecar ou lua-resty-jwt
    # return 401 se inválido/expirado/issuer errado

    proxy_pass http://churn_v2_backend;
  }
}
```

> Obs.: No lab, escolha **um** gateway (Traefik **ou** Nginx) para manter simplicidade. Integre o componente de AuthZ (ex.: OPA sidecar/forward-auth) e o **WAF** (CRS) no mesmo front.

---

## 6) Checklists operacionais

**Antes do go-live**

* [ ] Domínio + TLS válidos; **HSTS** habilitado.
* [ ] **mTLS** ativado em rotas internas.
* [ ] **JWT** validado (iss/aud/exp/nbf) + *clock skew* tratado.
* [ ] **RBAC/ABAC** por rota/versão/tenant testado (positivo/negativo).
* [ ] **Rate limit/quotas** por cliente/rota definidos.
* [ ] **WAF** com regras de API e *body inspection*; *false-positives* calibrados.
* [ ] **Schema básico** aplicado; **size limits** (request/response).
* [ ] **Erros padronizados**; mensagens sem revelar stack/infra.
* [ ] **Logs/métricas/tracing** integrados à Z9.
* [ ] **Kill switch** e **rollback** documentados e testados.

**Durante operação**

* [ ] Dashboards p95/p99, 4xx/5xx por rota/cliente.
* [ ] Alertas de 401/403/429/5xx em spikes.
* [ ] Rotação periódica de chaves/certs; verificação de expiração.
* [ ] Testes sintéticos (health + predição) contínuos.

---

## 7) Riscos × controles (recorte da Z6 para o gateway)

| Risco                               | Controles no Inference Gateway                                           |
| ----------------------------------- | ------------------------------------------------------------------------ |
| DoS/abuso                           | Rate limit/quotas, concurrency, timeouts, circuit breakers               |
| Broken Auth/Access                  | JWT/mTLS, RBAC/ABAC por rota/versão/tenant, revogação, DLP de cabeçalhos |
| Injection/Traversal/SSRF            | WAF para API, body inspection, path allowlist                            |
| Vazamento via erros/logs            | Erros padronizados, logs sem PII e com mascaramento                      |
| Bypass do gateway                   | Ponto único exposto + isolamento de rede (somente gateway na borda)      |
| Roubo/extração de modelo (scraping) | Throttling/quotas por identidade, detecção de padrão anômalo             |

---

## 8) Integrações de segurança

* **IdP/Keycloak**: emissão/validação de tokens, *client credentials*, *service accounts*.
* **Vault/KMS**: segredos do gateway, chaves TLS/mTLS, JWKS cache-secure.
* **OPA (ou equivalente)**: decisões fine-grained de autorização por rota/versão/tenant.
* **SIEM/Z9**: logs, métricas, traces, alertas e correlação com o restante da malha.

---

## 9) Runbooks (resumo)

* **Spike 429/DoS**: elevar limites por identidade crítica; bloquear origem abusiva; ativar *circuit breaker*; comunicar consumidores.
* **Tempestade 401/403**: checar **JWKS/issuer/audience**, clock skew, expiração; problemas no IdP; roteamento de *forward-auth*.
* **Erro p95 alto**: inspecionar upstream (modelo), latência de feature-store; ativar *degraded mode*; revisar timeouts/retries.
* **Cert expira amanhã**: rotação imediata via Vault/KMS; verificar cadeias intermediárias.
* **Falso positivo no WAF**: ajustar regra específica; manter *paranoia level* alto para rotas públicas; documentar exceção.

---

**Resumo para entrevista:**
“**Tudo** que toca modelo on-line passa pelo **Inference Gateway**. Ali eu **fecho a borda** (TLS/mTLS, WAF, rate limit), **provo identidade e escopo** (OIDC/mTLS, RBAC/ABAC por rota/versão/tenant), **garanto contrato de API** (método, path, content-type, tamanho, schema mínimo), **padronizo erros e headers de segurança**, e **rego tudo** em logs/métricas/tracing para **Z9**. Isso elimina bypass, reduz abuso e cria base de auditoria robusta para modelos em produção.”
