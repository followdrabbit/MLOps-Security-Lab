# Z6-2.2 — LLM/GenAI Security Gateway

*(Input/Output Filtering, PII Redaction, Anti Prompt-Injection & Exfiltração, Cost/SLO Controls)*

## 1) Papel e posicionamento

O **LLM/GenAI Security Gateway** é a **barreira obrigatória** entre **clientes internos** (apps, chatbots, RAG, automações) e **provedores/modelos LLM** (internos ou externos). Ele:

* **Filtra e normaliza entradas** (prompts, contextos, ferramentas) *antes* do modelo.
* **Aplica políticas de segurança e privacidade** (anti-prompt-injection, exfiltração, PII redaction).
* **Controla custo/latência** (rate-limit por custo/tokens, SLOs) e **observabilidade** (sem vazar PII).
* **Media o uso de ferramentas/plugins** (“tool calling”) com **allowlist** e **validação de parâmetros**.
* **Garante isolamento de contexto/tenant** no RAG (doc-level ACL, data-scope).

> Objetivo: reduzir riscos **específicos de GenAI** (injeção, vazamento, uso indevido de ferramentas, custo descontrolado) sem bloquear a produtividade.

---

## 2) Capacidades obrigatórias

### 2.1 AuthN/AuthZ e escopo de uso

* **AuthN**: OIDC/OAuth2 para clientes; *service-to-service* com mTLS quando sensível.
* **AuthZ** (RBAC/ABAC): por **tenant/canal/caso de uso**, **modelo/versão** e **ferramentas** permitidas.
* **Scopes**: `llm:chat`, `llm:rag:<collection>`, `llm:tool:<toolname>`.
* **Tokens de curta duração**; revogação em tempo quase real; *no hardcoded secrets* (Vault).

### 2.2 Input Filtering (antes do modelo)

* **Normalização**: remover controles invisíveis, unicode confuso, *zero-width*, *right-to-left override*, etc.
* **Tamanho/complexidade**: limites de **tokens**, **anexo**, **profundidade de prompt** e **tempo de execução**.
* **Anti Prompt-Injection (direta/indireta)**:

  * bloquear padrões como “ignore as instruções anteriores…”, “reveal system prompt…”, *jailbreaks* conhecidos;
  * isolar **system prompt** (imutável, somente gateway insere).
* **No-Secrets-in-Prompt**: remover/mascarar segredos, IDs sensíveis, chaves, *access tokens*.
* **RAG Guardrails**:

  * **Doc-level ACL** (somente documentos do tenant/usuário);
  * *query rewriting* seguro;
  * limites de **top-k**, **similaridade mínima**;
  * **proibição de “broad fetch”** (ex.: `*`/“return all docs”).
* **Schema de Tool Calls**: validações **fortes** de parâmetros (tipos, ranges, regex), *allowlist* de endpoints externos.

### 2.3 Output Filtering (após o modelo, antes do cliente)

* **Redaction/Masking de PII e segredos** (DLP): NER + padrões (CPF, cartão, chaves, e-mail, telefone).
* **Políticas de conteúdo**: bloquear respostas que contenham **segredos**, **técnicas de ataque**, **dados fora do escopo** do tenant.
* **Exfiltração**: detectar respostas que listem **conteúdo bruto de repositórios** (“dump all”, “full config”, “entire database”).
* **Post-processing seguro**: remover *stack traces*, `system prompt`, *chain-of-thought* e metadados internos.

### 2.4 Tooling/Plugins (Function Calling)

* **Allowlist** de ferramentas por **app/tenant**.
* **Validação de parâmetros** (tipos, comprimento, regex, *enum*), **timeouts** e **budget** de chamadas.
* **Side effects**: exigir **idempotência** ou compensação; logar **quem** acionou e **por quê**.
* **Sem dados sensíveis** como input padrão; **segredos** via Vault/sidecar.

### 2.5 Cost & SLO Controls

* **Rate-limit por custo e tokens** (ex.: `USD/min`, `tokens/min` por identidade/canal).
* **Budget/quotas** por projeto/equipe; *circuit breaker* por custo.
* **SLOs**: p95/p99 de latência por rota/modelo; **timeouts**; *degraded mode* (respostas resumidas/sem RAG).

### 2.6 Observabilidade e privacidade

* **Logs estruturados** (JSON) com: `request_id`, `tenant`, `model`, `version`, `tokens_in/out`, `cost_estimate`, `policy_decisions`.
* **Sem PII/segredos no log**; *hashing* ou *tokenization* para correlação.
* **Tracing** ponta-a-ponta (cliente → gateway → RAG/Tools → provedor) com **redação** de campos.
* **Métricas**: taxa de bloqueio por política, custos, latência, sucesso por ferramenta.

### 2.7 Provedores/Regiões/Chaves

* **Pin de região** (ex.: **não** enviar dados para regiões proibidas).
* **Chaves por ambiente/tenant**, rotacionadas via **Vault**; *least-privilege*.
* **Política de retenção**: *do not log prompts/responses* no provedor (quando opção existir); *data-control* ativado.

---

## 3) Fluxos de referência

### 3.1 Chat/Completion simples

1. Cliente → **LLM Gateway** (AuthN/AuthZ).
2. **Input Filtering** (anti-injection, size, no-secrets).
3. Chamada ao **modelo** (região/versão permitida).
4. **Output Filtering** (PII redaction, exfiltração).
5. **Audit** + métricas → resposta.

### 3.2 RAG (com ACL e limites)

1. Cliente → Gateway (AuthZ inclui **coleções/docsets** permitidos).
2. Query passada por **rewriter** seguro; aplica **top-k**, **score mínimo** e **doc-level ACL**.
3. Contexto montado e **sanitizado** (sem dados fora do tenant).
4. Envia ao modelo; **output filtering**; audit.

### 3.3 Tool Calling

1. Modelo solicita ferramenta `X`.
2. Gateway verifica **allowlist** e **política de parâmetros**.
3. Executa tool com **timeout/budget** e valida **resposta** (schema).
4. Retorna ao modelo; aplica **output filtering** e **audit**.

---

## 4) Políticas — exemplos (pseudo-Rego)

### 4.1 Anti-Prompt-Injection (entrada)

```rego
package llm.input
default allow = true
deny[msg] {
  re_match("(?i)ignore(.*)previous|reveal(.*)system prompt|jailbreak", input.prompt)
  msg := "Prompt-injection pattern blocked"
}
deny[msg] {
  count(input.tokens) > input.policy.max_tokens_in
  msg := "Input token limit exceeded"
}
deny[msg] {
  input.contains_secret == true
  msg := "Secrets in prompt are not allowed"
}
```

### 4.2 RAG — doc-level ACL

```rego
package llm.rag
default allow = false
allow {
  some d
  d := input.requested_docs[_]
  d.tenant == input.tenant
  d.classification in {"internal","confidential"}
  d.allowed == true
  count(input.requested_docs) <= input.policy.max_k
}
```

### 4.3 Output — PII/Exfil

```rego
package llm.output
default clean = true
violation["pii"] {
  some t
  t := input.tokens[_]
  t.class == "PII"
}
violation["exfil"] {
  re_match("(?i)(dump|print|return).*(all|entire).*(database|index|repository)", input.text)
}
```

### 4.4 Tools — allowlist e parâmetros

```rego
package llm.tools
default permit = false
permit {
  input.tool in {"weather","kb_search"}
  # valida tipos/ranges
  is_string(input.args.query)
  count(input.args.query) <= 256
}
```

---

## 5) Checklists operacionais

**Antes do go-live**

* [ ] System prompt **fixo/assinado** pelo gateway (imutável ao cliente).
* [ ] **Input/Output filters** habilitados e testados (positivos/negativos).
* [ ] **RAG ACL** por tenant; coleções e índices com *ownership* claro.
* [ ] **Allowlist** de tools/plugins e validação de parâmetros.
* [ ] **Rate-limit** por custo/tokens; *budget* e **circuit breaker**.
* [ ] Logs/métricas/tracing sem PII; *masking* aplicado; SLOs definidos.

**Durante operação**

* [ ] Monitorar **taxa de bloqueio** por política (false-positive vs. ataque real).
* [ ] **Custo/token** por cliente/canal; alertas de estouro de orçamento.
* [ ] Drift em conteúdo (mais redações de PII do que o normal?).
* [ ] Revisar **regras anti-injection** com base em tentativas recentes (inteligência de ameaças).

---

## 6) Riscos × Controles (recorte LLM)

| Risco                               | Controles no LLM Gateway                                                     |
| ----------------------------------- | ---------------------------------------------------------------------------- |
| Prompt-Injection (direta/indireta)  | Input Filtering (padrões, system prompt fixo), limites de tokens, RAG ACL    |
| Exfiltração de dados                | Output Filtering (exfil rules), doc-scope/tenant, bloqueio de “broad fetch”  |
| Vazamento de PII/segredos           | DLP/NER + redaction, *no-secrets-in-prompt*, logs sem PII                    |
| Abuso de ferramentas/plugins        | Allowlist, validação de parâmetros, timeout/budget, schema de resposta       |
| Custo descontrolado                 | Rate-limit por custo/tokens, *budget*, circuit breaker, SLOs                 |
| Cross-tenant no RAG                 | Doc-level ACL, partições por tenant, isolamento de índices                   |
| Logging indevido de dados sensíveis | Políticas de log mínimas, mascaramento, retenção, *do-not-store* no provedor |

---

## 7) Integrações de segurança

* **IdP/Keycloak**: emissão de tokens por app/tenant; *claims* com escopos de coleção/tool.
* **Vault/KMS**: chaves de provedores, *API keys*, *region pins*, *attestations*.
* **Z8 (DLP, catálogo, IAM)**: detecção de PII/segredos, classificação de coleções, *tags* de confidencialidade.
* **Z9**: dashboards de custo/latência/bloqueios; *traces* e auditoria de decisões de política.

---

## 8) Frases prontas (entrevista)

* “Todo uso de LLM passa pelo **LLM Security Gateway** — **nunca** direto no provedor.”
* “Bloqueamos **prompt-injection** e **exfiltração** *antes* do modelo; **redação de PII** e **no-secrets-in-prompt** são defaults.”
* “No RAG, **doc-level ACL** garante que cada tenant só acesse seus próprios documentos; *broad dumps* são bloqueados.”
* “Ferramentas só via **allowlist** e **validação de parâmetros**; custo é controlado por **budget de tokens** com **circuit breaker**.”
