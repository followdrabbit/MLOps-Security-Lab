# Z6-2.3 — Online Model Serving

*(Pods/Microservices • Somente Modelos Assinados • mTLS • NetworkPolicies • Runtime Hardening)*

## 1) Papel e posicionamento

Este componente **hospeda os serviços de inferência** (model servers / microservices) que expõem os modelos **aprovados** e **assinados** vindos da Z5. Ele transforma um artefato de modelo em uma **API confiável**, com **verificação de supply chain**, **comunicação autenticada/autorizada**, **rede mínima** e **execução endurecida**.

> Objetivo: “**servir com confiança**” — só sobe **modelo assinado**, roda **em sandbox**, conversa **apenas com quem deve**, e entrega **respostas dentro de contrato**.

---

## 2) Requisitos de segurança no runtime

### 2.1 Modelo como **artefato verificado** (assinatura, digest, attestation)

* **Baixar** o modelo do **Prod Model Registry (Z5)** **no startup** (init-container ou job).
* **Verificar**:

  * **assinatura** (ex.: cosign/sigstore, chave pública em **KMS/HSM**),
  * **digest** (SHA-256) esperado,
  * **attestations** (ex.: SBOM, varreduras, política de aprovação).
* **Falhar a inicialização** se qualquer verificação não passar (o serviço **não fica Ready**).

### 2.2 **Bootstrap seguro** (init-container + volume RO)

* **Init-container** faz: download → verificação → grava em volume **somente leitura** (read-only).
* O **container principal** **apenas lê** o artefato (sem permissão de escrita).
* **PreStop hook**: limpa caches temporários e encerra conexões.

### 2.3 Identidade & Segredos (service accounts + Vault Agent)

* **Service Account** dedicada por serviço de modelo (**não compartilhar**).
* **Segredos** (tokens, DSNs, chaves) via **Vault Agent/sidecar** → **sem** credenciais em variáveis/arquivos permanentes.
* **Tokens de curta duração** e escopo mínimo.

### 2.4 Comunicação segura (mTLS + AuthZ intra-serviço)

* **mTLS** entre **Inference Gateway** ⇄ serviço de modelo ⇄ (opcional) **Feature Retrieval Proxy**.
* **Autorização** por **SPIFFE ID**/SAN/claims do cliente (service-to-service).
* **TLS interno obrigatório**; sem “plain HTTP” entre pods.

### 2.5 **NetworkPolicies** (deny-by-default)

* **Ingress/Egress** bloqueados por padrão.
* Liberar **somente**:

  * tráfego do **Inference Gateway**,
  * tráfego para **Feature Proxy** (se existir),
  * métricas/logs para **Z9**,
  * (opcional) fetch do registry interno.
* **Nada** de acesso à internet “geral” a partir do pod.

### 2.6 Harden de containers/pods

* `runAsNonRoot: true`, `runAsUser` fixo (sem UID 0), `readOnlyRootFilesystem: true`.
* **NoNewPrivs**, **seccomp**/AppArmor, **drop** de capabilities (`ALL`).
* **Resource requests/limits** (CPU/mem) + **liveness/readiness** probes.
* **Pod Security Admission/Restricted**; **PDB** para manter réplicas mínimas.

### 2.7 **Schema enforcement** (Entrada/Saída)

* **Entrada**: validar **Content-Type**, **tamanho** e **schema** (JSON Schema/pydantic).
* **Saída**: **schema mínimo** e **redação** de campos sensíveis (sem PII/segredos).
* Rejeitar fora de contrato com **4xx** padronizado.

### 2.8 Resiliência, performance e SLO

* **Timeouts** internos, **limite de concorrência** (fila interna), **circuit breaker** no cliente (gateway).
* **Autoscaling** (HPA/KEDA) por **p95 latência**, **QPS** e **fila**.
* **Warm-up** de modelo e **graceful shutdown** (preStop + `terminationGracePeriod`).

### 2.9 Observabilidade (sem vazar dados)

* **Logs estruturados**: `request_id`, `model`, `version`, `latency_ms`, `status`. **Nunca** logar payload/PII.
* **Métricas**: p50/p95/p99, QPS, 4xx/5xx por rota, uso de CPU/mem.
* **Tracing** com propagação de contexto do gateway; envio para **Z9**.

### 2.10 Release management

* **Version pin** (o serviço anuncia **/vN** e carrega **digest** X).
* **Blue/green** ou **canary** com **rollback** rápido.
* **Kill switch** por versão/cliente (via política).

---

## 3) Fluxos de referência

### 3.1 Bootstrap (startup)

1. Init-container baixa `model.artifact` + `sig` + `attestations` do Registry (Z5).
2. Valida **assinatura/digest/política** → grava em volume **RO**.
3. Container principal sobe, **carrega o artefato**; fica **Ready** só se tudo OK.

### 3.2 Requisição de inferência

1. **Inference Gateway** (Z6-2.1) autentica/autoriza e envia via **mTLS**.
2. Serviço valida **schema** e (opcional) obtém features.
3. Executa predição → **resposta padronizada** → **logs/métricas** → Z9.

### 3.3 Atualização de versão

1. Novo **digest**/assinatura no Registry.
2. Rollout **canário**: pequeno % de tráfego.
3. SLO/erros OK → promover; se não, **rollback** imediato.

---

## 4) Exemplos de implementação (trechos)

### 4.1 Kubernetes — Deployment (resumo)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: churn-v2
spec:
  replicas: 3
  template:
    spec:
      serviceAccountName: sa-churn-v2
      securityContext:
        runAsNonRoot: true
      initContainers:
      - name: fetch-verify
        image: registry.local/tools/model-fetcher:1.0
        args: ["--model", "churn:v2", "--dest", "/model", "--verify"]
        volumeMounts: [{ name: model-ro, mountPath: /model }]
      containers:
      - name: server
        image: registry.local/ml/churn-server:2.3.1
        ports: [{ containerPort: 8080 }]
        readinessProbe: { httpGet: { path: /healthz, port: 8080 }, periodSeconds: 5 }
        livenessProbe:  { httpGet: { path: /livez,   port: 8080 }, periodSeconds: 10 }
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities: { drop: ["ALL"] }
        volumeMounts: [{ name: model-ro, mountPath: /srv/model, readOnly: true }]
        resources:
          requests: { cpu: "500m", memory: "512Mi" }
          limits:   { cpu: "2",    memory: "2Gi" }
      volumes:
      - name: model-ro
        emptyDir: { medium: "Memory" }  # tmpfs RO após init
```

### 4.2 Kubernetes — NetworkPolicy (deny-by-default + allow gateway)

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: np-churn-v2
spec:
  podSelector: { matchLabels: { app: churn-v2 } }
  policyTypes: ["Ingress","Egress"]
  ingress:
  - from:
    - podSelector: { matchLabels: { app: inference-gateway } }
    ports: [{ protocol: TCP, port: 8080 }]
  egress:
  - to:
    - podSelector: { matchLabels: { app: feature-proxy } }
    ports: [{ protocol: TCP, port: 7070 }]
```

### 4.3 Docker Compose (lab mínimo)

```yaml
services:
  churn-v2:
    image: ml/churn-server:2.3.1
    read_only: true
    security_opt:
      - no-new-privileges:true
    deploy:
      resources:
        limits: { cpus: '2', memory: 2G }
    environment:
      MODEL_PATH: /srv/model/model.onnx
    volumes:
      - type: tmpfs
        target: /srv/model
        tmpfs: { size: 134217728 } # 128MB
    networks: [ internal ]
networks:
  internal: {}
```

---

## 5) Políticas (pseudo-Rego/Kyverno) — exemplos

### 5.1 **Somente modelos assinados** (startup gate)

```rego
package serving.startup
default permit = false
permit {
  input.model.stage == "Approved"
  input.model.signatures.valid
  input.model.digest == input.expected_digest
  not input.model.revoked
}
```

### 5.2 Pod “restricted” obrigatório (Kyverno-like)

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata: { name: enforce-restricted-pod }
spec:
  rules:
  - name: require-restricted
    match: { resources: { kinds: ["Pod"] } }
    validate:
      pattern:
        spec:
          securityContext:
            runAsNonRoot: true
          containers:
          - =(securityContext):
              readOnlyRootFilesystem: true
              allowPrivilegeEscalation: false
```

---

## 6) Checklists operacionais

**Antes do go-live**

* [ ] Init-container verifica **assinatura/digest/attestations**.
* [ ] **mTLS** entre gateway ⇄ serviço; certificados válidos/rotacionados.
* [ ] **NetworkPolicies** (deny-by-default) aplicadas/testadas.
* [ ] **Schema I/O** implementado + erros padronizados.
* [ ] **SecurityContext** (non-root, RO FS, sem caps).
* [ ] **Autoscaling** e SLO (p95) configurados; **PDB** definido.
* [ ] **Logs/métricas/traces** na Z9 sem PII.

**Durante operação**

* [ ] Alertas por **picos de latência/erros**; *SLO burn rate* observado.
* [ ] Rotação de chaves/certs; vigiar expiração.
* [ ] Verificação periódica de **revogação** no Registry.
* [ ] Testes sintéticos de predição e **rollback** ensaiado.

---

## 7) Riscos × controles (recorte do serving)

| Risco                               | Controles no Online Serving                                                                |
| ----------------------------------- | ------------------------------------------------------------------------------------------ |
| Carregar modelo errado/alterado     | 2.1 verificação de assinatura/digest/attestation; **falha de readiness** se inválido       |
| Bypass/ataque lateral de rede       | 2.5 **NetworkPolicies** deny-by-default; mTLS com AuthZ intra-serviço                      |
| Execução com privilégios excessivos | 2.6 securityContext restritivo; **no-new-privs**, RO FS, caps drop                         |
| Input/Output fora de contrato       | 2.7 **schema enforcement** e limites de tamanho                                            |
| Degradação / DoS interno            | 2.8 timeouts, limite de concorrência, autoscaling por p95/fila, circuit breaker no gateway |
| Vazamento por logs                  | 2.9 logs mínimos, sem payload/PII, correlação por IDs                                      |
| Rollout inseguro                    | 2.10 version pin, canário/blue-green, kill switch, rollback rápido                         |

---

## 8) Integrações

* **Z5 (Registry & Governance)**: origem da verdade de `stage`, `digest`, `assinatura`, `revogação`.
* **Z6-2.1 (Gateway)**: controle de borda, rate-limit e autenticação/autorização.
* **Z6-2.4 (Feature Proxy)**: recuperação segura de features on-line.
* **Z8 (IAM/Vault/KMS/DLP)**: identidade de serviço, segredos dinâmicos e chaves de assinatura.
* **Z9 (Monitoring & Audit)**: logs, métricas e traces ponta-a-ponta.

---

## 9) Frases prontas (entrevista)

* “O serviço **só inicia** se o modelo **passar na verificação** de **assinatura/digest/attestation**; caso contrário, **não fica Ready**.”
* “Executo **como não-root**, **FS somente leitura**, **sem capabilities**, **NetworkPolicies** *deny-by-default* e **mTLS** em todas as hops.”
* “Valido **schema** de entrada/saída, imponho **limites** e **não logamos payload** — só IDs, latência e status para a Z9.”
* “Rollout é **canário/blue-green** com **rollback** e **kill switch**; a versão exposta é **fixada por digest**.”
