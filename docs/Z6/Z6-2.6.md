# Z6-2.6 — Scored Output Store

*(Resultados de Inferência • Governança • Privacidade • Imutabilidade Controlada • Consumo via Contrato)*

## 1) Papel e posicionamento

O **Scored Output Store** é o **repositório autoritativo** das **saídas de inferência** (on-line e batch). Ele consolida predições, probabilidades, rótulos derivados/decisões e metadados de execução, com **governança forte**, **privacidade por padrão**, **trilhas de auditoria** e **contratos de consumo** para Z7 (Core/Risk/Fraud/Apps).

> Objetivo: garantir que **toda saída de modelo** seja **rastreável, reproduzível, minimamente exposta** e **consumida somente por APIs/contratos aprovados**.

---

## 2) Capacidades obrigatórias

### 2.1 Modelo de dados (schema governado)

* **Campos mínimos (on-line & batch)**
  `request_id`, `tenant_id`, `entity_key` (tokenizada/HMAC),
  `model_name`, `model_version`, `model_digest`,
  `score` (probabilidade/valor), `decision?` (opcional),
  `as_of_in` (tempo de dados/feature), `as_of_out` (tempo da inferência),
  `featureset_id?` (hash/versão do conjunto), `explanations?` (SHAP/resumo),
  `runtime_meta` (latência, servidor, zona), `policy_digest`.
* **Campos sensíveis** (PII/segredos) **não entram** no store (ou entram **derivados/tokenizados**).
* **Tipos explícitos** (ex.: Parquet/Arrow): facilita validação e leitura analítica.

### 2.2 Particionamento, versionamento e naming

* **Partições** por **data/hora** e, quando útil, por **modelo** e **tenant**.
  Ex.: `s3://scored/<model>/<version>/dt=YYYY-MM-DD/tenant=<id>/part=*`
* **Versionamento de objetos** habilitado (para auditoria e correções guiadas).
* **Convenções de nomes** reproduzíveis (p. ex., `job_id`, `chunk_id`, `part-N.parquet`).

### 2.3 Integridade, idempotência e exactly-once

* **Chave idempotente**: `idempo_key = hash(request_id|model_digest|entity_key|as_of_out)`.
* **Escrita em *staging* + *commit atômico*** (mover/renomear) para evitar leituras parciais.
* **Deduplicação** server-side por `idempo_key` quando suportado (ex.: Iceberg/Hudi) ou na camada de leitura.

### 2.4 Segurança de dados (em repouso e em trânsito)

* **Criptografia em repouso** (SSE-KMS/HSM).
* **Criptografia em trânsito** (TLS/mTLS) nos writers/leitores.
* **ACL/RBAC/ABAC**: *write-only* para **Online Serving** (Z6-2.3) e **Batch Orchestrator** (Z6-2.5); leitura apenas por **APIs autorizadas** (Z7) e **jobs de auditoria** (Z9).
* **Políticas de bucket/table** negando acesso público e **listar objetos** sem permissão explícita.

### 2.5 Privacidade por padrão (LGPD)

* **Tokenização/HMAC** de `entity_key` (chave no Vault/KMS).
* **Mascaramento** de campos potencialmente sensíveis nas **rotas de leitura**.
* **Minimização**: guardar **apenas** o necessário para rastreabilidade e negócio.
* **Direitos do titular**: plano/rotina para **expurgo ou pseudonimização forte** quando aplicável.

### 2.6 Leitura e consumo (via contrato)

* **Ninguém lê “direto do bucket”** em produção. Z7 consome via **APIs com contrato** (filtros, paginação, schema).
* **Camadas de visão** (Views/Endpoints):

  * *Operational view*: última predição por entidade (indexada).
  * *Analytical view*: histórico particionado (somente times autorizados).
* **CDC/eventos**: publicação de **eventos de disponibilidade** após *commit* (ex.: “scores para dt=2025-11-12 prontos”).

### 2.7 Observabilidade e auditoria

* **Manifesto de escrita** por lote ou janela on-line: contagem `rows_in/out`, *checks* e hashes.
* **Logs estruturados** (sem payload sensível) com `request_id`, `model/version/digest`, `writer`, `latência`, `commit_id`.
* **Trilhas** enviadas à Z9; **reconciliação** periódica (manifesto vs. objeto real).

### 2.8 Retenção, ciclo de vida e imutabilidade

* **Lifecycle** por classificação/uso (ex.: 90–365 dias on-line; 2–5 anos arquivado).
* **WORM (Object Lock)** opcional para **proteger auditoria** (com política de exceção governada).
* **Expurgo programado** + **log de exclusão** (quem/por que/quando).

### 2.9 Desempenho e escala

* **Formato colunar** (Parquet/Arrow) para batch/analytics;
* **Índices secundários** ou **hot store** (OLTP) para *lookup* on-line “última predição”.
* **Compressão** (ex.: ZSTD/Snappy) e **tamanho de arquivo** adequado (64–256 MB por part).

### 2.10 Governança e catálogo

* **Catálogo de dados** com **classificação**, **dono**, **propósito**, **retenção**, **sensibilidade** e **contratos**.
* **Data contracts** versionados (Git/ADR/SCDR) e **políticas como código** (Rego).

---

## 3) Fluxos de referência

### 3.1 Escrita — Online Serving

1. Serviço de modelo finaliza predição → monta **registro de saída** (campos mínimos + metadados).
2. Escreve em **landing/staging** (com `idempo_key`), confirma *ACK*.
3. Processo de **commit atômico** move para partição final → **evento de disponibilidade**.

### 3.2 Escrita — Batch

1. Orquestrador escreve *partitions* em **staging**;
2. Valida contagem, sanidade e manifesto;
3. Executa **commit** → publica **manifest.json** e **_SUCCESS**.

### 3.3 Leitura — Z7 (via API)

1. Sistema consumidor chama **Scored Output API** com filtros (tenant, entidade, janela, modelo).
2. API aplica **AuthZ**, **masking**, **rate-limit** e paginação → retorna **view** contratada.

---

## 4) Políticas — exemplos (pseudo-Rego)

### 4.1 Só grava quem pode (writers restritos)

```rego
package scored.write
default allow = false

allow {
  input.caller in {"svc-online-serving","svc-batch-orchestrator"}
  input.action == "write"
  input.bucket == "scored"
}
```

### 4.2 Leitura por tenant + máscara de campos

```rego
package scored.read
default permit = false

permit {
  input.action == "read"
  input.tenant == input.claims.tenant
  input.route in {"/api/scored/v1/search","/api/scored/v1/last"}
}

mask[field] {
  field in {"entity_key","explanations"}
  input.claims.role != "risk-analyst"
}
```

### 4.3 Retenção e exclusão

```rego
package scored.retention
delete_allowed {
  input.classification == "operational"
  now() - input.record.as_of_out > input.policy.retention_days * 24 * 60 * 60
}
```

---

## 5) Exemplos de implementação (trechos)

### 5.1 S3/MinIO — políticas e versionamento

```bash
# Habilitar versionamento
aws s3api put-bucket-versioning \
  --bucket scored \
  --versioning-configuration Status=Enabled

# Exemplo de policy (resumo): negar público, permitir apenas roles específicas
{
  "Version": "2012-10-17",
  "Statement": [
    { "Effect": "Deny", "Principal": "*", "Action": "s3:*", "Resource": [
        "arn:aws:s3:::scored", "arn:aws:s3:::scored/*"
      ],
      "Condition": { "Bool": { "aws:SecureTransport": "false" } }
    },
    { "Effect": "Allow", "Principal": { "AWS": ["arn:aws:iam::123:role/svc-online-serving",
                                                "arn:aws:iam::123:role/svc-batch-orchestrator"] },
      "Action": ["s3:PutObject","s3:AbortMultipartUpload","s3:ListBucketMultipartUploads"],
      "Resource": ["arn:aws:s3:::scored/*"]
    }
  ]
}
```

### 5.2 Parquet — schema mínimo (exemplo)

```sql
-- conceitual
request_id STRING,
tenant_id  STRING,
entity_key STRING,         -- HMAC/tokenizada
model_name STRING,
model_version STRING,
model_digest STRING,
score DOUBLE,
decision STRING NULL,
as_of_in TIMESTAMP,
as_of_out TIMESTAMP,
featureset_id STRING NULL,
explanations BINARY NULL,  -- compactado/limpo
runtime_meta MAP<STRING,STRING>,
policy_digest STRING
```

### 5.3 Hot store (lookup rápido da última predição)

```sql
CREATE TABLE last_scores (
  tenant_id   TEXT NOT NULL,
  entity_key  TEXT NOT NULL,
  model_name  TEXT NOT NULL,
  model_major SMALLINT NOT NULL,
  as_of_out   TIMESTAMP NOT NULL,
  score       DOUBLE PRECISION NOT NULL,
  decision    TEXT,
  policy_digest TEXT,
  PRIMARY KEY (tenant_id, entity_key, model_name, model_major)
);
-- Escrita apenas por serviço autorizado; leitura por API com masking.
```

### 5.4 Object Lock / WORM (opcional, auditoria)

* **Modo**: *governance* (pode liberar sob exceção) ou *compliance* (irrevogável até expirar).
* **Uso**: habilitar somente nas **partições de auditoria** e **manifestos**.

---

## 6) Checklists operacionais

**Antes do go-live**

* [ ] **Schema governado** versionado; contratos com Z7 publicados.
* [ ] **Criptografia**, **ACL** e **versionamento** habilitados.
* [ ] **Idempotência** (`idempo_key`) e **commit atômico** testados.
* [ ] **Tokenização/HMAC** do `entity_key`; chaves no Vault/KMS.
* [ ] **Views/Endpoints** de leitura com **masking** e **rate-limit**.
* [ ] **Lifecycle/retention** definidos + (opcional) **WORM** para auditoria.

**Durante operação**

* [ ] Reconciliação manifesto↔partições; alarmes de inconsistência.
* [ ] Monitorar **dedupe** e **taxa de reprocessamento**.
* [ ] Custos de storage (compressão/part size).
* [ ] Revisões periódicas de **quem lê** e **por que** (access review).

---

## 7) Riscos × Controles (recorte do store)

| Risco                                  | Controles no Scored Output Store                                          |
| -------------------------------------- | ------------------------------------------------------------------------- |
| Vazamento de PII ou chave de entidade  | Tokenização/HMAC, masking na leitura, minimização, ACL/ABAC               |
| Reprocesso duplicado / inconsistência  | Idempotência + commit atômico + dedupe                                    |
| Acesso direto/bypass do contrato       | *Write-only* para writers; leitura **apenas via APIs** com AuthZ e schema |
| Alteração/eliminação indevida (fraude) | Versionamento, auditoria, WORM (opcional), roles restritas                |
| Consumo analítico fora de escopo       | Views separadas, catálogos/classificação, autorização por domínio/equipe  |
| Quebra de rastreabilidade              | Manifestos, `model_digest`, `policy_digest`, `request_id` e Z9 audit      |

---

## 8) Integrações

* **Z6-2.3 (Online Serving)** / **Z6-2.5 (Batch)**: **únicos writers**.
* **Z7 (Consumers)**: consumo **via APIs com contrato** (operacional/analítico).
* **Z8 (IAM/Vault/KMS/DLP/Catálogo)**: identidade, chaves, políticas de DLP e metadados.
* **Z9 (Monitoring & Audit)**: manifestos, logs de commit, reconciliação e trilhas.

---

## 9) Frases prontas (entrevista)

* “O **Scored Output Store** é **autoridade única** das saídas de modelo; **ninguém** lê direto do bucket — só via **APIs com contrato**.”
* “Garantimos **idempotência e exactly-once**: *staging + commit atômico* e `idempo_key` por registro.”
* “**Privacidade por padrão**: `entity_key` **HMAC**, **masking** na leitura e **minimização** de campos.”
* “**Rastreabilidade completa**: `model_digest`, `policy_digest`, manifestos, versionamento e integração com a **Z9** para auditoria.”
