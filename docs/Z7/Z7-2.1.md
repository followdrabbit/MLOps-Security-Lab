# Z7-2.1 — Core Banking / Risk / Fraud Engines

*(Decisão transacional • Contratos de API • Idempotência • Propósito (LGPD) • Observabilidade por rota)*

## 1) Papel e posicionamento

Sistemas **Core/Risk/Fraud** tomam **decisões transacionais** (aprovar/recusar, limite, alçada, fila de revisão) **consumindo modelos com governança**. Eles **nunca** acessam storage bruto:

* **Online**: chamam **Inference Gateway (Z6-2.1)** para *predict* síncrono (modelos clássicos) e **LLM Security Gateway (Z6-2.2)** quando houver GenAI.
* **Leitura de resultados**: usam **Scored Output Access API (Z6-2.7)** para “**/last**” ou histórico paginado (“**/search**”).
* **Escrita**: registram **decisão** e **reason codes** em seus próprios domínios (sem PII extra vindo de Z6).

---

## 2) Capacidades obrigatórias

### 2.1 Integração com Z6 por **contratos**

* **Predict**: `POST /predict` (via **Inference Gateway**) com `tenant`, `entity_key_hmac`, **contexto mínimo**.
* **Last/Historic**: `GET /api/scored/v1/last` e `POST /api/scored/v1/search` (via **Scored Output API**).
* **Sem leitura direta** de buckets/tabelas; **SDK interno** padroniza AuthN/AuthZ, *retries*, idempotência e telemetria.

### 2.2 Identidade, AuthN/AuthZ e propósito

* **AuthN**: OIDC client-credentials + **mTLS** (service-to-service).
* **AuthZ (ABAC)**: escopos por **tenant/rota/modelo**; *row-level filtering*.
* **Propósito declarado (LGPD)** por rota/consumidor (catálogo + SCDR).
* **Segredos** via **Vault Agent** (sem credenciais hardcoded).

### 2.3 Confiabilidade de chamada (resiliência)

* **Timeouts curtos** (ex.: 200–500 ms por hop), **retries com backoff** (poucas tentativas), **jitter**.
* **Circuit breakers** (Resilience4j/Envoy/Istio) com **fallback** explícito (regras de negócio sem modelo ou “/last”).
* **Rate limit** por identidade/rota; **quotas** de custo (quando LLM).

### 2.4 Idempotência e consistência

* **`request_id`** único por decisão transacional (evita **double-submit**).
* **Correlações** (`request_id` ↔ `predict_id`) nos logs dos dois lados.
* Ao consumir “/last”, exigir **commit atômico** (Z6-2.6) e usar **cursores `since_ts`** para reconciliação.

### 2.5 Regras de negócio, *cut-offs* e *human-in-the-loop*

* Modelo gera **score**; **motor de regras** aplica **cut-offs**, *bands* e **exceções regulatórias**.
* **Fila de revisão** para incerteza/alto risco (HITL), com **explicabilidade** controlada (quando permitido).
* **Reason codes** padronizados (não expor features/PII).

### 2.6 Privacidade por padrão (UI/Logs)

* **Minimização** de campos nas chamadas e respostas.
* **Masking** em UI e **logs sem payload sensível** (apenas chaves, tempos, status).
* **PII/HMAC** tratados no lado **Z6**; Z7 não reverte tokenização.

### 2.7 Observabilidade & auditoria

* **Métricas por rota**: QPS, p95/p99, taxa de erro, *score coverage*, custo (LLM).
* **Logs estruturados**: `request_id`, `tenant`, `route`, `latency_ms`, `decision`, **sem PII**.
* **Tracing end-to-end** (core ↔ gateway ↔ serving ↔ store); envio para **Z9**.
* **Access reviews** periódicos e **ADR/SCDR** para mudanças de contrato.

### 2.8 Disponibilidade & DR

* **Ativo–ativo** (multi-AZ) para *predict*; **degradação** para regras-only se Z6 estiver indisponível.
* **Failover** controlado; **orçamentos de indisponibilidade** por produto.

---

## 3) Fluxos de referência

### 3.1 Decisão on-line (alto nível)

1. **Core** recebe evento → cria `request_id`.
2. Chama **Inference Gateway** (`/predict`) com `tenant`, `entity_key_hmac`, contexto essencial.
3. Recebe `score`, `model_version`, `as_of_in/out`, `policy_digest`.
4. **Regras** aplicam **cut-off** e exceções → decisão (**approve/deny/hold**).
5. **Auditoria**: loga `request_id`, `decision`, `model_version`, latência; **sem PII**.

### 3.2 Fallback (modelo indisponível)

* **Circuit breaker abre** → usar **regras-only** ou **“/last”** (política).
* **Sinalizar degradação** (header/flag) para posterior reconciliação.

### 3.3 Reconciliação e histórico

* Em D+1, **Risk** consulta **“/search”** para janela do dia e reconcilia **decisão vs score**; investiga outliers.

### 3.4 HITL

* Casos “**hold**” vão para fila de **revisão**;, *playbook* registra justificativas e **resultados** para *feedback loop*.

---

## 4) Políticas — exemplos (pseudo-Rego)

### 4.1 Permissão de *predict* por tenant/rota

```rego
package z7.core.predict
default allow = false

allow {
  input.route == "/predict"
  input.claims.tenant == input.body.tenant
  input.claims.scope[_] == "predict:online"
}
```

### 4.2 Leitura operacional “/last” com janela limitada

```rego
package z7.core.last
default permit = false

permit {
  input.route == "/api/scored/v1/last"
  input.claims.role == "core-banking"
  input.window_hours <= 24  # evita histórico amplo em sistemas transacionais
}
```

### 4.3 Propósito declarado (LGPD)

```rego
package z7.purpose
default ok = false

ok {
  input.claims.purpose == "credit_decisioning"
  input.route in {"/predict","/api/scored/v1/last"}
}
```

---

## 5) Exemplos de implementação (trechos)

### 5.1 Cliente (SDK) — pseudo-Python

```python
from sdk_z6 import InferenceClient, ScoredApi
from resilience import with_circuit_breaker, retry

inf = InferenceClient(oidc_client_id="core", mtls_cert="/etc/tls/cert.pem")
scored = ScoredApi(oidc_client_id="core", mtls_cert="/etc/tls/cert.pem")

@with_circuit_breaker(name="predict", failure_rate=0.2, open_secs=5)
@retry(tries=2, backoff=0.05, jitter=True)
def decide(request_id, tenant, entity_key_hmac, ctx):
    resp = inf.predict(
        tenant=tenant,
        entity=entity_key_hmac,
        context=ctx,               # minimizado
        timeout_ms=300
    )
    score = resp["score"]
    mv    = resp["model_version"]
    # motor de regras (bands + exceções)
    if score >= 0.85: decision = "approve"
    elif score <= 0.25: decision = "deny"
    else: decision = "hold"
    audit_log(request_id, tenant, mv, decision, score)  # sem PII
    return decision

def fallback_last(request_id, tenant, entity_key_hmac):
    last = scored.get_last(tenant=tenant, entity=entity_key_hmac, model="churn")
    # política define se podemos usar "last" ou regras-only
    return "hold" if not last else ("approve" if last["score"]>=0.9 else "hold")
```

### 5.2 Circuit breaker (Resilience4j — exemplo)

```yaml
resilience4j:
  circuitbreaker:
    instances:
      predict:
        failureRateThreshold: 20
        slowCallRateThreshold: 30
        slowCallDurationThreshold: 300ms
        permittedNumberOfCallsInHalfOpenState: 5
        slidingWindowSize: 50
        waitDurationInOpenState: 5s
```

### 5.3 K8s — ServiceAccount + NetworkPolicy (resumo)

```yaml
apiVersion: v1
kind: ServiceAccount
metadata: { name: sa-core }
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata: { name: np-core }
spec:
  podSelector: { matchLabels: { app: core-engine } }
  policyTypes: ["Egress","Ingress"]
  egress:
  - to: [ { namespaceSelector: { matchLabels: { ns: z6-gateway } } } ]
    ports: [ { protocol: TCP, port: 443 } ]
  ingress:
  - from: [ { namespaceSelector: { matchLabels: { ns: front } } } ]
    ports: [ { protocol: TCP, port: 8443 } ]
```

---

## 6) Checklists operacionais

**Antes do go-live**

* [ ] **OpenAPI** das rotas usadas (predict/last/search) estável e versionada.
* [ ] **SDK** integrado (Auth, *retries*, idempotência, telemetria).
* [ ] **Circuit breakers** + **fallback policy** definidos/testados.
* [ ] **ABAC/Propósito** configurados; mínimo de campos no contrato.
* [ ] **Logs sem PII**, *request_id* em toda a cadeia, **tracing** ativo.

**Durante operação**

* [ ] Monitore **p95/p99**, taxa de erro e **custo** por rota/consumidor.
* [ ] **Score coverage** e **hold rate** por produto.
* [ ] Reconciliação diária (decisão ↔ score) e revisão de **reason codes**.
* [ ] *Access reviews* trimestrais (quem lê, o que e por quê).

---

## 7) Riscos × Controles × Referências

| Risco em Core/Risk/Fraud                | Controles em Z7-2.1                                                                   | Referências (exemplos)                        |
| --------------------------------------- | ------------------------------------------------------------------------------------- | --------------------------------------------- |
| **Dependência frágil** de modelos/rotas | **SDK** interno, OpenAPI versionado, *feature flags*, depreciação guiada              | NIST CM-*; OWASP ASVS                         |
| **Enumeração/cross-tenant** por leitura | **ABAC** por tenant/rota; *row-level filtering*; limites de janela/paginação          | OWASP API (API1/API5); NIST AC-*              |
| **Exposição de PII** em UI/logs         | **Masking/redaction**, minimização, logs sem payload                                  | LGPD; NIST SC-28; CSA DSI                     |
| **Indisponibilidade** de predição       | **Circuit breakers**, *fallbacks* (regras-only / last), *timeouts/retries*            | NIST CP-*; SRE SLO/SLA                        |
| **Uso de score obsoleto/inconsistente** | “/last” com **commit atômico**, cursores `since_ts`, reconciliação D+1                | Z6-2.6/2.7                                    |
| **Decisão injusta/sem justificativa**   | **Bands/cut-offs** + **HITL**, reason codes padronizados, *explainability* controlada | NIST AI RMF (Map/Measure/Manage); MITRE ATLAS |
| **Abuso/custo** (LLM)                   | **Quotas** por identidade/rota, rate limit, *budget alerts*                           | CSA AICM; OWASP LLM/GenAI                     |

---

## 8) Integrações

* **Z6-2.1 / Z6-2.2**: porta de predição; aplica **Auth**, rate limit, *traffic shaping*.
* **Z6-2.7**: leitura governada de **“/last”** e **“/search”**.
* **Z8**: **Vault/IAM/KMS/DLP/Catálogo** (identidade, segredos, classificação e propósito).
* **Z9**: métricas, logs e auditoria (reconciliações e *access reviews*).

---

## 9) Frases prontas (entrevista)

* “Core/Risk/Fraud **nunca** lê bucket — usa **Inference Gateway** para *predict* e **Scored Output API** para `last/search`, com **ABAC** e **masking**.”
* “Implementamos **idempotência** com `request_id`, **circuit breakers** e **fallback** claro; preferimos **segurança e traçabilidade** à opacidade.”
* “**Propósito (LGPD)** e **minimização** guiam os contratos; **logs sem PII** e **tracing E2E** vão para a **Z9**.”
* “Decisão = **score + regras** (*bands*, exceções) + **HITL** quando necessário; **reason codes** padronizados para auditoria.”
