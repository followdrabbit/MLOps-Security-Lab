# Z7-2.5 — Client Adapter / SDK (Contrato de Consumo)

*(Padroniza Auth • Idempotência • Retries/Backoff • Telemetria • Masking • Versionamento de Contratos)*

## 1) Papel e posicionamento

O **SDK** é a “cola” confiável entre **consumidores Z7** (Core, Canais, Back-office, Chatbots) e as **APIs governadas da Z6** (Inference Gateway, LLM Gateway, Scored Output Access API).
Ele **padroniza segurança e resilência**, evita “client spaghetti” em cada sistema e **faz cumprir** o contrato de consumo (OpenAPI v1/v2), reduzindo acoplamento e risco.

> Regra de ouro: *ninguém chama as APIs de inferência direto; chama via SDK.*

---

## 2) Capacidades obrigatórias

### 2.1 Autenticação & Autorização

* **OIDC (client-credentials)** com **tokens curto-vivos** e **rotacionados**.
* **mTLS** s2s: validação de **CA corporativa**, *SAN* e revogação.
* **ABAC**: injeta *claims* (tenant, role, purpose) no header (ex.: `X-Purpose`), quando aplicável.
* **Zero hardcode**: credenciais **vêm do Vault Agent** (file/pipe/env injetado).

### 2.2 Confiabilidade de chamada

* **Timeouts** defensivos (ex.: 300–800 ms por hop), **retrias com backoff exponencial + jitter** (poucas tentativas).
* **Circuit breaker** integrado (ex.: Resilience4j/Envoy/Istio) com **fallback** explícito (regras-only ou `/last`).
* **Rate limiting** por identidade **no próprio cliente** (auto-throttling) para evitar *dogpiles*.

### 2.3 Idempotência & correlação

* **Gera `request_id`** (UUIDv7) quando não houver.
* **`Idempotency-Key`** por decisão transacional (evita double submit).
* Propaga **W3C Trace Context** (`traceparent`) e **`X-Request-Id`**.

### 2.4 Privacidade e minimização

* **Schemas tipados** que **impedem** enviar campos além do contrato.
* **Masking/redaction** lado-cliente para *defense-in-depth* em logs.
* **Proibido** cachear PII; respostas sensíveis **não persistem** no cliente.

### 2.5 Observabilidade

* **OpenTelemetry** (traces/spans/attrs), **métricas** (`latency_ms`, `error_rate`, `cost/tokens`), **logs estruturados** (sem payload).
* **Labels**: `tenant`, `route`, `model`, `version`, `http_status`.

### 2.6 Versionamento de contratos

* Suporte a **OpenAPI v1/v2** com **feature flags** por versão.
* **Depreciação guiada**: warnings com prazo; *fail-fast* após *EoL*.
* **Negociação de versão** via header (`Accept-Version`) ou base path.

### 2.7 Segurança do artefato

* Build com **SBOM** + **assinatura** (Sigstore/Cosign).
* **Lints** de segurança (SAST), **scan** de dependências e **políticas** “fail-the-build”.
* Publicado em **repositório privado** com **proveniência** (SLSA-like).

---

## 3) Interfaces públicas (API do SDK)

### 3.1 Modelos clássicos (Inference Gateway)

```ts
// TypeScript (assinaturas)
predict(input: {
  tenant: string;
  entity_key_hmac: string;      // nunca PII crua
  context: Record<string, any>; // mínimo necessário
  timeoutMs?: number;
}): Promise<{ score: number; model_version: string; as_of_in: string; as_of_out: string }>;
```

### 3.2 Leitura operacional (Scored Output Access API)

```ts
getLast(input: {
  tenant: string;
  entity_key_hmac: string;
  model: string;
}): Promise<{ score: number; model_version: string; as_of_out: string }>;

search(input: {
  tenant: string;
  model: string;
  from: string; to: string;     // ISO-8601 UTC
  page?: number; size?: number;
  filters?: Record<string, any>;
}): AsyncIterable<{ entity_key_hmac: string; score: number; as_of_out: string }>;
```

### 3.3 GenAI (LLM Gateway)

```ts
chat(input: {
  tenant: string; user_id: string; role: string;
  messages: Array<{role:"user"|"system"|"assistant", content:string}>;
  tools_allow?: string[]; rag?: { enabled: boolean; top_k?: number };
  budget_hint?: { daily_tokens?: number };
}): Promise<{ answer: string; citations?: string[]; policy: { pii_redacted: boolean } }>;
```

---

## 4) Fluxos típicos

### 4.1 Decisão on-line

1. App chama `predict()` com `tenant`, `entity_key_hmac`, `context` mínimo.
2. SDK: **token OIDC**, **mTLS**, **timeout/retry**, **trace**.
3. Resposta: **score + versão**; app aplica **regras/bands**.

### 4.2 `/last` para reconciliação

1. Back-office chama `getLast()`;
2. SDK aplica **ABAC** e **masking** em logs;
3. Resposta somente com campos **permitidos**.

### 4.3 Chat interno

1. UI → BFF → `chat()`;
2. SDK injeta **claims** e **budget**; Gateway faz **input/output filtering**.

---

## 5) Políticas como código (trechos)

### 5.1 Bloquear payload fora do contrato

```rego
package sdk.contract
deny[msg] {
  some k
  input.context[k]
  not k in {"product","channel","amount"}   # somente chaves aprovadas
  msg := sprintf("campo não permitido: %s", [k])
}
```

### 5.2 Restrições de versão

```rego
package sdk.version
allow {
  input.accept_version == "v2"
  time.now_ns() < time.parse_rfc3339_ns("2026-01-01T00:00:00Z")
}
```

---

## 6) Implementação (snippets)

### 6.1 Python (requests + otel)

```python
import os, uuid, requests, time
from opentelemetry import trace

CA = "/etc/pki/ca.crt"
CERT = ("/etc/tls/tls.crt", "/etc/tls/tls.key")  # mTLS
OIDC_TOKEN_FILE = "/vault/secrets/oidc_token"    # Vault Agent

def _token():
    return open(OIDC_TOKEN_FILE).read().strip()

def predict(tenant, entity_key_hmac, context, timeout=0.6):
    rid = str(uuid.uuid7())  # uuid7 = ordenável por tempo
    headers = {
        "Authorization": f"Bearer {_token()}",
        "X-Request-Id": rid,
        "Accept-Version": "v2",
        "Content-Type": "application/json",
        "X-Purpose": "credit_decisioning"
    }
    # minimização defensiva
    allowed = {"product","channel","amount"}
    ctx = {k:v for k,v in context.items() if k in allowed}
    t0 = time.time()
    try:
        r = requests.post(
            "https://gw.internal/predict",
            json={"tenant": tenant, "entity_key_hmac": entity_key_hmac, "context": ctx},
            headers=headers, timeout=timeout, cert=CERT, verify=CA
        )
        r.raise_for_status()
        body = r.json()
        return {"score": body["score"], "model_version": body["model_version"], "latency_ms": (time.time()-t0)*1000}
    except requests.Timeout:
        # fallback policy definida no chamador (ex.: regras-only)
        raise
```

### 6.2 Node/TS (Axios + CB + Retry)

```ts
import axios from "axios";
import { CircuitBreaker } from "opossum";
import fs from "fs";

const token = () => fs.readFileSync("/vault/secrets/oidc_token","utf8").trim();

const client = axios.create({
  baseURL: "https://gw.internal",
  httpsAgent: new (require("https").Agent)({
    cert: fs.readFileSync("/etc/tls/tls.crt"),
    key:  fs.readFileSync("/etc/tls/tls.key"),
    ca:   fs.readFileSync("/etc/pki/ca.crt"),
    keepAlive: true,
  }),
  timeout: 800,
});

async function _predict(req) {
  return client.post("/predict", req, {
    headers: { Authorization: `Bearer ${token()}`, "Accept-Version":"v2", "X-Purpose":"credit_decisioning" }
  });
}

export async function predict(input) {
  const breaker = new CircuitBreaker(_predict, { errorThresholdPercentage: 20, resetTimeout: 5000 });
  let attempts = 0, lastErr;
  while (attempts++ < 2) {
    try { return (await breaker.fire(input)).data; }
    catch(e){ lastErr = e; await new Promise(r=>setTimeout(r, 50+Math.random()*50)); }
  }
  throw lastErr;
}
```

---

## 7) Testes & qualidade

* **Contract tests** (OpenAPI) — geram *stubs* e validam requests/responses.
* **Golden tests** — cenários fixos com *fixtures* para detectar regressões.
* **Chaos/testing** de timeouts/erros (simulação de falhas da Z6).
* **Lint de segurança** (no secrets in code), **scan** de dependências, **SBOM**.

---

## 8) Observabilidade (SDK)

* **Métricas**: `predict_latency_ms{tenant,route,version}`, `predict_error_total{status}`, `cost_tokens_total` (LLM).
* **Traces**: span `sdk.predict` com **`model_version`** retornada; correlação com Z6/Z9.
* **Logs**: só **metadados** (sem PII/payload), sempre com `request_id`.

---

## 9) Segurança & hardening

* **Pinning** do CA corporativo; rejeitar TLS < 1.2; **cipher suites** seguras.
* **Clock-skew**: tolerância ±60s para tokens; sincronizar NTP.
* **Fail-safe**: no erro desconhecido, **não** enviar novamente payloads grandes.
* **Desligar** verbos/documentos legados via *feature flags* (kill-switch no cliente).

**Anti-padrões (bloqueados pelo SDK):**

* Chamadas **diretas** a buckets/tabelas.
* Enviar **PII crua** (e.g., CPF sem tokenização/HMAC).
* **Logar** payload completo/respostas com score.
* **Retries agressivos** que pioram um incidente.

---

## 10) Checklists operacionais

**Antes do uso**

* [ ] OpenAPI consumida e **versão** selecionada (v1/v2).
* [ ] **Vault Agent** configurado (token OIDC, segredos).
* [ ] **mTLS** com CA corporativa e certificados válidos.
* [ ] **Timeouts/retries/circuit breaker** afinados por rota.
* [ ] **Telemetria** (OTel) exportando para **Z9**.

**Durante operação**

* [ ] Monitorar p95/p99, taxa de erro, **custo/tokens** (LLM).
* [ ] Alertas para **spikes** de `429/5xx` e **rate-limit** local.
* [ ] Revisão periódica de **versões** (depreciações) e **chaves**.

---

## 11) Riscos × Controles × Referências

| Risco no consumo direto                   | Controle via SDK                                                         |
| ----------------------------------------- | ------------------------------------------------------------------------ |
| **Quebra de contratos / drift de schema** | Schemas tipados + **contract tests** + negociação de versão              |
| **Exposição de PII**                      | **Minimização + masking** + logs sem payload                             |
| **Indisponibilidade cascata**             | **Timeouts**, **retries** com jitter, **circuit breaker** + **fallback** |
| **Abuso de API/custos**                   | **Rate-limit local**, quotas (LLM), monitoração de custo                 |
| **Segredos expostos**                     | **Vault Agent**, tokens curto-vivos, mTLS, **zero hardcode**             |
| **Clientes divergentes por time**         | **SDK único**, publicado e assinado; guidelines e *lint rules*           |

(Alinhado a **OWASP ASVS/API Security**, **CSA AICM**, **NIST SP 800-53 (AC-*, SC-*, AU-*)** e **NIST AI RMF** no que tange governança de uso.)

---

## 12) Integrações

* **Z6**: Inference/LLM/Scored APIs (porta única).
* **Z8**: Vault/IAM/KMS para segredos e identidade.
* **Z9**: export de métricas, logs e traces.

---

## 13) Frases prontas (entrevista)

* “Padronizamos consumo via **SDK com OIDC+mTLS**, **idempotência** e **telemetria OTel**; **nada** fala direto com a Z6.”
* “O SDK **impede campos fora do contrato**, aplica **retries/backoff** e **circuit breaker** com **fallback** controlado.”
* “Privacidade por padrão: **minimização**, **masking** e **logs sem payload**; segredos via **Vault Agent**.”
* “Gerimos **versões de contrato** (OpenAPI v1/v2) com **flags** e **depreciação guiada**, reduzindo acoplamento e risco.”
