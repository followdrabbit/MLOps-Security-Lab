# Z8-2.5 — Data Protection (DLP, Masking, Tokenização/Pseudonimização)

- ↩️ [Voltar ao Z8 — Security & Trust Services](./Z8-index.md)
- ↩️ [Voltar ao README — Mapa Z0–Z9](../../README.md)

> **Resumo**: Esta camada implementa **privacy-by-design** ponta a ponta: **descoberta/classificação** de dados, **controles de saída (DLP)**, **mascaramento dinâmico**, **tokenização/pseudonimização** e **criptografia por campo**. Permite acesso **por propósito** (LGPD), reduz **exposição indevida** (logs/saídas/API/LLM) e integra **KMS/Vault/OPA** para decisões auditáveis.

---

## 1) Objetivos & Escopo

**Objetivos**

* Identificar e **classificar** dados (PII/PCI/PHI, sensibilidade, finalidade).
* Reduzir **superexposição** via **masking dinâmico**, **tokenização** e **field-level encryption**.
* Impedir **exfiltração** com **DLP** em **ingresso/egresso** (APIs, gateways, jobs, LLM).
* **Vincular acesso à finalidade** declarada (purpose binding) e registrar **evidências**.

**Escopo**

* **Z1** (entrada): validações de conteúdo + **bloqueio de PII onde não permitido**.
* **Z2/Z3** (armazenamento/curadoria): criptografia, tokenização, retenção, minimização.
* **Z6/Z7** (serving/consumo): **redação/masking** em respostas, DLP de saída e **controle por propósito**.

---

## 2) Ameaças principais

* Vazamento por **resposta de API**, **UI**, **logs**, **arquivos de saída** (batch) e **prompts/outputs LLM**.
* **Acesso fora de propósito** (uso secundário não autorizado; *function creep*).
* **Dados reais em ambientes não-prod** (dev/test) sem de-id.
* **Reidentificação** por *joins* inadvertidos/ataques de inferência.
* Falhas de **retenção/eliminação** (dados eternos).

---

## 3) Componentes & Controles

### 3.1 Descoberta, Classificação & Catálogo

* **Scanners** (regex, dicionários, detectores ML) identificam PII/segredo por **coluna/campo**.
* **Taxonomia**: `class` (PII-Sensível/PII-Básica/PCI/PHI), `purpose` (ex.: *risk-scoring*), `owner`, `retention`.
* **Lineage**: Z0→Z7 com *run_id*, **policy_digest**, aprovadores.
* **Contrato**: metadados **obrigatórios** para datasets/saídas: `purpose`, `retention_days`, `pii={true|false}`, `masking_profile`.

### 3.2 Masking Dinâmico (RBAC/ABAC/Purpose)

* **Runtime masking** em APIs/SQL/Views conforme **papel, atributos, propósito**.
* Perfis comuns:

  * **Full** (somente *need-to-know*): `123.456.789-09`
  * **Masked** (parcial): `***.***.***-09`
  * **Hashed/Redacted**: `sha256:ab…` / `REDACTED`
* **OPA/Rego** decide **quais campos** e **nível de detalhe** (ex.: auditor vs. operador).
* **Logs** e métricas **sem PII** (campos sensíveis removidos/mascarados por padrão).

### 3.3 Tokenização & Pseudonimização

* **Determinística** (mesma entrada → mesmo token) para **joins/analytics**.
* **Format-Preserving** (FPE) quando formato é exigido (ex.: manter padrão de CPF/tel).
* **Reversível sob controle** (vault + *reveal policy*) para casos de necessidade legal.
* **Irreversível** (hash/salt/pepper) quando reidentificação **jamais** é necessária.
* **Vault/KMS** guarda **tabelas de mapeamento/keys**; operações auditadas e com **SoD**.

### 3.4 Field-Level Encryption (FLE)

* Cifra **por coluna/campo** (cliente-side) usando **Envelope Encryption** (Transit/KMS).
* **Contexto/tweak** por domínio (evita *cross-join* de domínios diferentes).
* **AEAD/HMAC** para integridade; **versões** de chaves no metadado.

### 3.5 DLP de Egresso (APIs/Batch/LLM)

* **API Gateway** (Z6) aplica **redaction** automática de PII em payloads de resposta.
* **Batch Orchestrator** valida **perfil de saída** antes de escrever em *Scored Output Store*.
* **LLM/GenAI Gateway**: **input filtering** + **output filtering** (PII, segredo, *prompt-exfil*).
* **Egress proxies** (HTTP/S3/email) com **políticas DLP**; bloqueio, *quarentena*, *justificativa*.

### 3.6 Retenção, Minimização & RTBF

* **Retention schedules** por `class/purpose`; **WORM** quando aplicável (trilha/forense).
* **Right-to-be-forgotten** (LGPD): *locate → re-tokenize/erase* com **evidence link**.
* **Ambientes não-prod**: **somente de-id** (tokens/mascaras), **jamais dados reais**.

---

## 4) Contratos & Padrões

### 4.1 Metadados obrigatórios (datasets/saídas)

```yaml
dataset: churn_events
classification: PII-Basica
purpose: risk-scoring
owner: squad-risk
retention_days: 365
pii: true
masking_profile: default
tokenization: deterministic-fpe
```

### 4.2 Perfis de masking (exemplo)

```yaml
profiles:
  default:
    cpf: mask-last4
    email: redact-user
    phone: mask-middle
  auditor:
    cpf: full
    email: full
  analytics:
    cpf: tokenized-deterministic
    email: hash
```

---

## 5) Fluxos de referência

### 5.1 Tokenização determinística (ingest → curated)

1. Z1 aceita evento → **DLP/validation OK**.
2. Conector Z3 aplica **tokenização determinística** (Vault/Transit) nas chaves PII.
3. Grava token + **metadados de propósito**; mapeamento guardado no Vault.
4. **Revelação** só com política de exceção (aprovadores/SoD, auditoria).

### 5.2 Masking dinâmico na resposta (Z6/Z7)

1. Cliente chama rota de inferência com JWT + **purpose**.
2. **OPA** decide **nível de masking** por campo.
3. **BFF/Gateway** aplica *redaction/masking* antes de responder; logs **sem PII**.

### 5.3 DLP para LLM

1. Prompt entra no **LLM Gateway** → **input filter** remove PII/segredos.
2. Resposta do modelo → **output filter** (regex/ML) + **obligations** (ex.: “remova campos X”).
3. Eventos → **Z9** (policy_digest, dec_id).

---

## 6) Riscos × Controles × Frameworks

| Risco                             | Controle                                                             | Referências (ex.)                       |
| --------------------------------- | -------------------------------------------------------------------- | --------------------------------------- |
| Vazamento por API/UI/logs/LLM     | **Masking dinâmico**, **redaction**, **DLP** no gateway/BFF/egresso  | NIST SC-28/AU-*; CSA **DSI/LOG**; OWASP |
| Uso fora de propósito (LGPD)      | **Purpose binding** + **ABAC** (OPA) + evidências                    | NIST PM-*; LGPD; CSA **GRC/IAM/AAC**    |
| Reidentificação/links indesejados | **Tokenização determinística** controlada + **context/tweak** em FLE | NIST 800-122; CSA **EKM/DSI**           |
| Dados reais em dev/test           | **De-id** obrigatório; *golden datasets* sintéticos                  | NIST CM-*; SSAF/SSDF (governança)       |
| Ausência de retenção/eliminação   | **Retention schedules**, **RTBF** com *evidence link*                | NIST CP-9/MP-6; LGPD                    |

---

## 7) Checklists operacionais

**Antes do go-live**

* [ ] Taxonomia de **classificação** e **purpose** publicada; catálogo com *owners*.
* [ ] **Perfis de masking** e **políticas OPA** versionados e testados.
* [ ] **Tokenização** (determinística/FPE) integrada ao Z3; **map store** no Vault.
* [ ] **DLP** configurado nos gateways (Z6) e batch (Z6-2.7); **LLM filters** ativos.
* [ ] **Retention/RTBF** testados com evidências.

**Operação contínua**

* [ ] *Access reviews* por purpose/tenant; auditoria de **reveal events**.
* [ ] *Drift* de políticas de masking/DLP monitorado (spikes de *deny*).
* [ ] Testes de **reidentificação** (ataques de *linkage*).
* [ ] Validação de que **logs** permanecem **sem PII**.

**Incidente**

* [ ] **Bloquear egressos**, ativar *quarentena* e **notificar**; gerar **evidence pack**.
* [ ] Revisar **políticas OPA** e perfis de masking; ajustar **DLP rules**.
* [ ] Executar **RTBF** para registros afetados (se aplicável).

---

## 8) Exemplos práticos

**8.1 Rego — autorização por propósito + masking profile**

```rego
package z6.privacy
default allow = false
default profile = "default"

allow {
  input.purpose == "risk-scoring"
  input.claims.tenant == input.tenant
  some s
  s := input.claims.scopes[_]
  s == sprintf("inference:%s:%s:invoke", [input.model.name, input.model.version])
}

profile = "auditor" {
  allow
  input.claims.role == "auditor"
}
```

**8.2 Pseudocódigo — aplicação de perfil de masking**

```python
def apply_masking(payload, profile):
    rules = MASK_PROFILES[profile]
    for field, rule in rules.items():
        if field in payload:
            payload[field] = MASK_RULES[rule](payload[field])
    return payload
```

**8.3 Vault Transit — tokenização determinística (FPE-like)**

```bash
# (exemplo conceitual) cifra determinística com contexto
vault write transit/encrypt/pii \
  plaintext=$(printf "12345678909" | base64) \
  context=$(printf "tenant=bankA|purpose=risk-scoring" | base64) \
  key_version=2
```

**8.4 Perfil de DLP para LLM Gateway (YAML)**

```yaml
llm_dlp:
  input_block:
    - secret.*(key|token|password)
    - \b\d{3}\.\d{3}\.\d{3}\-\d{2}\b   # CPF
  output_redact:
    - email
    - phone
    - national_id
  obligations:
    - add_banner: "Redacted for privacy"
```

**8.5 View SQL — masking por role (exemplo genérico)**

```sql
CREATE VIEW v_clientes_secure AS
SELECT
  CASE WHEN has_role('auditor') THEN cpf ELSE mask_last4(cpf) END AS cpf,
  CASE WHEN has_role('auditor') THEN email ELSE redact_user(email) END AS email,
  ...
FROM clientes_raw;
```

---

## 9) Frases prontas (entrevista)

* “**Acesso por propósito**: cada dataset/rota carrega `purpose`; OPA decide *allow + masking profile* — **deny-by-default**.”
* “Em **serving**, aplico **masking dinâmico** e **DLP de saída**; logs **nunca** trazem PII.”
* “Uso **tokenização determinística** ou **FPE** para preservar *joins* sem expor o valor real; *reveal* é raro, **auditado** e com **SoD**.”
* “Para LLM, tenho **input/output filtering** anti-exfil e **obligations** de *redaction*; tudo cai na Z9 com **policy_digest**.”
