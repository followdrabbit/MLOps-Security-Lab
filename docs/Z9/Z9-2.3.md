# Z9-2.3 — Tracing Distribuído (OpenTelemetry)

## Objetivo e escopo

Implementar **traces ponta-a-ponta** (E2E) para seguir uma requisição desde a **borda de ingestão (Z1)**, passando por **pipelines/serviços (Z2–Z6)**, até o **consumo (Z7)** — com correlação consistente a **logs e métricas** e envio para a **camada de monitoramento/auditoria (Z9)**. As zonas já preveem esse encadeamento: Z1 e Z2 encaminham eventos a Z9; Z6 e Z7 exigem **traces E2E** em produção.    

---

## Conceitos essenciais (OTel)

* **Trace**: a jornada completa de uma transação.
* **Span**: um trecho dessa jornada (ex.: “Z1 → validação”, “Z6 → /predict”).
* **Attributes**: chaves/valores para consulta (ex.: `tenant`, `route`, `model_version`).
* **Events**: marcações pontuais (ex.: “policy_denied”, “dlp_redacted”).
* **Links**: unem traces paralelos (útil em **batch** ou em **fan-out**).
* **Baggage**: metadados que viajam com a requisição (use com parcimônia; **sem PII**).

---

## Padrões de propagação

* **W3C Trace-Context** (`traceparent`/`tracestate`) em **HTTP** e **mensageria**.
* Mensageria/ETL: copie o **Trace-ID** para **headers do MQ**; em **batch**, use **Links** para cada item processado.
* **Chave de correlação** adicional (ex.: `correlation_id` do negócio) pode coexistir, mas o **Trace-ID** é o pivô universal.

**Relação com as zonas**

* **Z1** cria/aceita o trace e acrescenta *spans* de gateway/WAF/validação; eventos são enviados para **Z9**. 
* **Z6** inclui *spans* de **/predict**, filtros de entrada/saída e sinais de risco (abuso, scraping, jailbreak). 
* **Z7** registra *spans* de consumo, com **traces end-to-end** e métricas p95/p99 por rota/tenant.  
* **Z2** (Raw) e stores registram **logs de acesso** correlacionados (→ Z9), permitindo investigar “quem acessou o quê e quando”.  

---

## Topologia recomendada

* **OTel SDK** em cada serviço (Z1, Z6, Z7, jobs Z2–Z5).
* **OTel Collector (agent + gateway)**: recebe OTLP/HTTP|gRPC, aplica **amostragem**, **atributos padrão**, **redação de PII** e exporta para **Jaeger/Tempo** e para o **SIEM (Z9)**. (Z6 e Z7 já exigem logs/métricas/traces integrados a Z9.)  

---

## Esquema de atributos (sem PII)

Padronize **resource attributes** e **span attributes** para consultas e painéis:

**Resource (serviço)**

* `service.name`, `service.version`, `deployment.environment`
* `team`, `zone` ∈ {Z1…Z7}, `runtime` (python, node, java)

**Span**

* **Geral**: `tenant`, `route`, `http.status_code`, `component` (gateway, waf, model-svc), `correlation_id`
* **Modelo (Z6)**: `model_name`, `model_version`, `model_stage`, `policy_digest` (quando aplicável) 
* **Consumo (Z7)**: `consumer_app`, `use_case`, `purpose` (LGPD), `sdk.version` 

> **Privacidade**: nunca registrar PII/payload em atributos; Z6 e Z7 já exigem **logs mínimos** e **masking/redaction**.  

---

## Amostragem

* **Head sampling** default (ex.: 5–20%) + **tail sampling** para **erros/p95 alto** e **sinais de risco** (abuso, scraping, jailbreak). Esses sinais são expostos por Z6. 
* Elevar taxa em **rotas críticas** (produção) e reduzir em **health-checks**.

---

## Correlação logs ↔ traces ↔ métricas

* JSON log com `trace_id`/`span_id` em **Z1/Z6/Z7**, exportados ao **SIEM (Z9)**.   
* Métricas por rota/tenant (p95/p99, taxa de erro, custo) alinhadas ao **service graph** dos traces (Z7). 

---

## Fluxos de referência

### A) Online (/predict — Z6 → Z7)

1. **Z1** recebe `POST /ingest`, cria/propaga `traceparent`. Eventos de auditoria vão a **Z9**. 
2. **Z6** recebe a chamada, cria *spans*: `authz`, `input_filter`, `model_infer`, `output_redaction`. 
3. **Z7** consome a resposta, registra *span* do client-adapter/SDK com **telemetria padronizada** e **traces E2E**.  

### B) Batch (Airflow → Z6-2.5)

1. Job cria **root span** “batch-run” (inclui `run_id`, `model_version fixada`).
2. Para cada partição, cria *spans* filhos; se fan-out, usar **Links**.
3. Saída governada em **Scored Output Store** com logs de escrita para **Z9**. 

---

## Riscos × Controles × Frameworks (Z9-Tracing)

| Risco observável                                   | Controles de tracing                                                    | Onde se ancora                        |
| -------------------------------------------------- | ----------------------------------------------------------------------- | ------------------------------------- |
| **Gaps de propagação** (perda de Trace-ID em hops) | Testes de integração e **policy de headers**; Collector valida e alerta | Z6/Z7 exigem E2E + integração Z9.     |
| **Logs com PII/segredos**                          | Atributos padronizados **sem PII** + redaction/masking em saída         | Z6/Z7 políticas de logs mínimos.      |
| **Investigações lentas** (sem correlação)          | `trace_id`/`span_id` em logs; *service graph*; *exemplars* de métricas  | Z1/Z2→Z9 e Z6/Z7→Z9.                  |
| **Uso fora de propósito**                          | Traces + SIEM para detectar padrões anômalos de consumo                 | Z7 monitora padrões por rota/tenant.  |

---

## Checklists

**Antes do go-live**

* [ ] **Trace-Context** habilitado no gateway (Z1), serviços (Z6) e SDK de consumo (Z7). 
* [ ] **Collector** com *processors* de **redação** (sem PII) e **amostragem** por regra. 
* [ ] **Padrão de atributos** documentado (`tenant`, `route`, `model_version`, `purpose`). 
* [ ] **Dashboards**: p95/p99 por rota/tenant, erros, custo (Z7). 

**Operação**

* [ ] *Alertas* para **quedas de taxa de amostragem** e **quebra de propagação**.
* [ ] *Playbooks* de investigação (abrir trace → filtrar por `tenant`/rota/modelo → cruzar logs SIEM). (Z9 centraliza). 
* [ ] *Reviews* periódicos de **atributos padrão** e **cardinalidade**.

---

## Trechos práticos

**(a) FastAPI — auto-instrumentação OTLP**

```python
# pip install opentelemetry-distro opentelemetry-exporter-otlp opentelemetry-instrumentation-fastapi
from fastapi import FastAPI, Request
from opentelemetry import trace
from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor
from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor

app = FastAPI()
provider = TracerProvider()
provider.add_span_processor(BatchSpanProcessor(OTLPSpanExporter(endpoint="http://otel-collector:4318/v1/traces")))
trace.set_tracer_provider(provider)
FastAPIInstrumentor.instrument_app(app)

@app.get("/health")
def health():
    return {"ok": True}
```

**(b) Log JSON com correlação**

```json
{"ts":"2025-11-15T20:00:00Z","level":"INFO","msg":"predict ok",
 "trace_id":"7f3c5d...","span_id":"9ab21c...",
 "tenant":"banking-core","route":"/api/churn/v2/predict","model_version":"2.3.1"}
```

**(c) Collector — sampling + redaction (esboço)**

```yaml
receivers:
  otlp: { protocols: { http: {}, grpc: {} } }
processors:
  batch: {}
  attributes/redact:
    actions:
      - key: user_email
        action: delete
  tail_sampling:
    policies:
      - name: errors
        type: status_code
        status_code: { status_codes: [ERROR] }
      - name: high_latency
        type: latency
        latency: { threshold_ms: 500 }
exporters:
  otlphttp/jaeger: { endpoint: "http://jaeger:4318" }
  otlphttp/siem:   { endpoint: "http://siem-bridge:4318" }
service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch, attributes/redact, tail_sampling]
      exporters: [otlphttp/jaeger, otlphttp/siem]
```

> Resultado: **traces E2E, logs e métricas** conectados por `trace_id`, com **privacidade preservada** e **investigação rápida** em Z9 — coerente com as exigências já descritas em **Z1, Z2, Z6 e Z7**.
