# Z9-2.9 — FinOps & Capacity (Custo, Orçamentação e Planejamento de Capacidade)

↩️ Voltar: [Z9 — Monitoring, Observability & Audit](./Z9-index.md) · Relacionados: Z6 (Serving & LLM Gateway), Z7 (Consumo), Z8-2.6 (SIEM/UEBA/SOAR), Z9-2.2 (Métricas), Z9-2.7 (Alerting/SLOs)

> **Resumo**: Observabilidade **financeira e de capacidade** para inferência online/batch e workloads de LLM/GenAI. Mede **custo por rota/tenant/modelo**, **tokens**, **utilização de GPU/CPU/Mem**, **egress/storage**, **queue depth** e **backlog time**. Dispara **guardrails** (quotas, *throttling*, *tiered routing*, *cache*) e apoia **previsão de demanda** e **orçamento**.

---

## 1) Objetivos & escopo

**Objetivos**

* Tornar **custos previsíveis** (FinOps) e garantir **capacidade suficiente** com eficiência.
* Fornecer **SLIs/SLOs financeiros** (custo por 1k requisições/tokens) e **técnicos** (utilização, latência).
* Automatizar **respostas** quando orçamento, quotas ou limites de capacidade forem violados.

**Escopo**

* **Online** (Inference Gateway/LLM Gateway), **Batch** (orquestrador), **Armazenamento/Egress** (Z2/Z3) e **Aceleração** (GPU).
* **Dimensões**: `tenant`, `rota`, `modelo` (e `versão`), `região`, `ambiente`.

---

## 2) Modelo de medição (dados necessários)

* **Custo direto**: preço por *request/token* (LLM), custo/hora de GPU/CPU, egress/GB, storage/GB-mês.
* **Uso**: *requests/s*, *tokens in/out*, *context length*, latência p95/p99, *cache hit-ratio*.
* **Capacidade**: GPU/CPU/RAM/VRAM *utilization*, *queue depth*, *backlog time*, *concurrency*.
* **Metadados**: `tenant`, `route`, `model.name`, `model.version`, `region`, `policy_digest`.

> **Padronização**: as métricas devem seguir a convenção de rótulos já definida em Z9-2.2.

---

## 3) SLIs/SLOs financeiros & de capacidade (exemplos)

### 3.1 Financeiros

* **Custo por 1k requisições** (por rota/tenant/modelo).
* **Custo por 1k *tokens*** (LLM) e **tokens médios por requisição**.
* **Orçamento mensal** (por tenant/produto) e **burn rate** (dia/semana/mês).
* **Egress/storage** (GB/dia, GB-mês) por domínio de dados.

### 3.2 Capacidade

* **Utilização de GPU/CPU/RAM/VRAM** (média e p95).
* **Queue depth** e **backlog time** por fila/rota.
* **Concurrency** por *deployment* e **taxa de *throttling*** aplicada.
* **Cache hit-ratio** (LLM e feature cache).

---

## 4) Guardrails & respostas automáticas

* **Quotas por tenant/rota** (req/s, tokens/dia, custo/dia).
* **Throttling adaptativo** (redução suave de TPS quando *burn rate* sobe).
* **Tiered routing** (alternar para modelo **mais barato**/distilado sob pressão).
* **Prompt controls** (limitar *context length*, ativar **prompt compression**).
* **Cache obrigatório** para prompts repetidos/last-N context.
* **Janela de manutenção** para *batch* quando *online* estiver sob stress.
* **Circuit breakers** de custo/capacidade (S1) com *fail-closed* para rotas sensíveis.

---

## 5) Painéis (dashboards) recomendados

* **Visão executiva**: custo total/dia, previsão do mês, *top tenants/rotas*, custo por 1k req/tokens, *burn* vs. orçamento.
* **LLM**: tokens in/out, custo por rota, *context length*, *hit-ratio*, *prompt filters hits*.
* **Capacidade**: GPU/CPU/VRAM, *queue depth/backlog*, *throttling rate*, *autoscaling events*.
* **Egress/Storage**: GB/dia, GB-mês, *hot vs. cold*; *cost drivers* por domínio de dados.

---

## 6) Alertas (exemplos PromQL)

**6.1 — Burn rate do orçamento (LLM)**

```promql
# custo atual > 2x média diária das últimas 2 semanas
rate(inference_cost_usd_total{zone="Z7"}[1h])
> 2 * avg_over_time(inference_cost_usd_total{zone="Z7"}[14d])
```

**6.2 — Tokens por requisição acima do limite**

```promql
avg_over_time( llm_tokens_total{type="input",route="/api/llm/predict"}[15m] )
/
avg_over_time( http_requests_total{route="/api/llm/predict"}[15m] )
> 1.5 * on(route) group_left avg_over_time(llm_tokens_baseline{route="/api/llm/predict"}[7d])
```

**6.3 — Utilização de GPU crítica e fila crescendo**

```promql
( avg_over_time(gpu_utilization{deployment="model-x"}[5m]) > 0.9 )
and
( rate(inference_queue_depth{deployment="model-x"}[5m]) > 0 )
```

**6.4 — Cache ineficiente (oportunidade de economia)**

```promql
(1 - avg_over_time(llm_cache_hit_ratio{route="/api/llm/predict"}[1h])) > 0.7
```

---

## 7) Exemplos de políticas (OPA/Rego)

**7.1 — Quota de tokens diária por tenant**

```rego
package z9.finops.quota
default allow = true
deny[msg] {
  input.route == "/api/llm/predict"
  input.tenant_quota.tokens_daily > 0
  input.tenant_usage.tokens_today + input.request.tokens > input.tenant_quota.tokens_daily
  msg := sprintf("quota exceeded: tenant=%v", [input.tenant])
}
```

**7.2 — Tiered routing por custo**

```rego
package z9.finops.routing
default target_model = "gpt-distilled"
target_model = "gpt-premium" {
  input.slo.latency_ok
  input.budget.burn_rate < 1.0
}
```

---

## 8) Playbooks (SOAR) — respostas de FinOps/Capacidade

* **Custo S2/S1**: reduzir *context length*, habilitar **cache agressivo**, *tiered routing* para modelo *distilled*, aplicar **quotas**; notificar produto/FinOps.
* **Capacidade S2**: *scale-out* (se houver orçamento), *batch deferral*, realocar tráfego por região.
* **Capacidade S1**: *circuit breaker* para rotas não críticas, priorizar *core/risk/fraud*, acionar *war-room* SRE+produto.
* **Egress/storage**: mover *cold data* para classe barata, ativar *lifecycle policies*.

---

## 9) Riscos × Controles × Frameworks

| Risco                          | Controles (neste módulo)                                               | Conexões       |
| ------------------------------ | ---------------------------------------------------------------------- | -------------- |
| **Explosão de custos LLM**     | quotas, *burn rate* alert, *tiered routing*, cache, prompt compression | Z6, Z7, Z9-2.7 |
| **Saturação de GPU/CPU**       | autoscaling, *queue/backlog* monitor, *batch deferral*, priorização    | Z6, Z4         |
| **Orçamento estourado no mês** | previsão + *guardrails* por tenant/produto, reports executivos         | Z7, FinOps     |
| **Egress/storage caros**       | lifecycle policies, *cold storage*, compactação                        | Z2/Z3          |

> **Referenciais**: práticas **FinOps** (unidade de custo por produto/tenant), SRE (SLOs), boas práticas de **Kubernetes** (ResourceQuota, HPA/VPA) e *rate limiting* em API Gateways.

---

## 10) Checklists

**Antes do go-live**

* [ ] Definir **unidade de custo** (1k req / 1k tokens / job batch) por produto/tenant.
* [ ] Publicar **orçamentos** e **quotas** iniciais; configurar *burn rate alerts*.
* [ ] Instrumentar **tokens/req**, **custo**, **utilização** e **cache hit-ratio**.
* [ ] Habilitar **tiered routing** e **prompt controls** (LLM).
* [ ] Painéis executivos e operacionais prontos.

**Operação**

* [ ] Revisar **previsão** semanal/mensal (tendência vs. orçamento).
* [ ] Ajustar **quotas** e **SLOs** conforme uso real e prioridades.
* [ ] Auditar **custos por tenant/rota** e abrir CAPA para *cost anomalies*.
* [ ] Revisar *lifecycle policies* de storage/egress trimestralmente.

---

## 11) Frases prontas (entrevista)

* “Eu **atribuo custo** por `tenant/rota/modelo` e monitoro **burn rate** com **guardrails** (quotas, *tiered routing*, cache, *prompt compression*).”
* “Capacidade é medida por **GPU/CPU/VRAM**, **queue/backlog** e **concurrency**; sob pressão aplico **throttling adaptativo** e priorização de rotas críticas.”
* “Tenho **painéis executivos** de custo/previsão e **alertas** de tokens/contexto; integro **OPA** para negar chamadas que estouram **quotas**.”
